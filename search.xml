<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring-事务传播级别</title>
    <url>/2017/01/05/2017-01-05-Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h2 id="一、TransactionPropagation"><a href="#一、TransactionPropagation" class="headerlink" title="一、TransactionPropagation"></a>一、TransactionPropagation</h2><ul>
<li>PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</li>
<li>PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。</li>
<li>PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。</li>
<li>PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li>PROPAGATION_NESTED – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。<br>前六个策略类似于EJB CMT，第七个（PROPAGATION_NESTED）是Spring所提供的一个特殊变量。<br>它要求事务管理器或者使用JDBC 3.0 Savepoint API提供嵌套事务行为（如Spring的DataSourceTransactionManager）</li>
</ul>
<p>其中对于PROPAGATION_REQUIRES_NEW与PROPAGATION_NESTED的理解上有些类似，关键在于嵌套事务的理解。</p>
<p>来看一下网上大神对Juergen Hoeller表述的翻译：</p>
<blockquote>
<p>PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。</p>
<p>另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务,  它是已经存在事务的一个真正的子事务. 嵌套事务开始执行时,  它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交. </p>
</blockquote>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serviceA.methodA() &#123;</span><br><span class="line">	doSomethingA();</span><br><span class="line">	serviceB.methodB();</span><br><span class="line">	doSomethingB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2017/01/05/2017-01-05-Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%BA%A7%E5%88%AB/image-20200428135125561.png" alt="image"></p>
<h2 id="二、Spring事务之UnexpectedRollbackException异常"><a href="#二、Spring事务之UnexpectedRollbackException异常" class="headerlink" title="二、Spring事务之UnexpectedRollbackException异常"></a>二、Spring事务之UnexpectedRollbackException异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serviceA.methodA()</span><br><span class="line">&#123;  </span><br><span class="line">doSomethingA();  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">            serviceB.methodB&#123;&#125;; <span class="comment">//这里面有异常标记为回滚, doSetRollbackOnly(status);  </span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;  </span><br><span class="line">               <span class="comment">//捕获异常转到commit时，由于已经标记为要回滚， 回滚并抛出新异常     </span></span><br><span class="line">       &#125;         </span><br><span class="line">   doSomethingB();  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>因为在ServiceA和ServiceB中的@Transactional  propagation都采用的默认值：REQUREID。根据我们前面讲过的REQUIRED特性，当ServiceA调用ServiceB的时候，他们是处于同一个transaction中。</p>
<p>当ServiceB中抛出了一个异常以后，ServiceB会把当前的transaction标记为需要rollback。但是ServiceA中捕获了这个异常，并进行了处理，认为当前transaction应该正常commit。但因为methodB有异常事务，已经被标记为回滚，在commit时spring会判断回滚标志，若检测到存在回滚标记， 则回滚事务并抛出UnexpectedRollbackException异常。</p>
]]></content>
      <categories>
        <category>Spring JPA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring JPA</tag>
        <tag>数据库</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim - 快捷键</title>
    <url>/2017/12/24/2017-12-24-Vim-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="Vim-快捷键"><a href="#Vim-快捷键" class="headerlink" title="Vim - 快捷键"></a>Vim - 快捷键</h1><h2 id="启动Vim"><a href="#启动Vim" class="headerlink" title="启动Vim"></a>启动Vim</h2><ul>
<li>vim -c cmd file: 在打开文件前，先执行指定的命令；</li>
<li>vim -r file: 恢复上次异常退出的文件；</li>
<li>vim -R file: 以只读的方式打开文件，但可以强制保存；</li>
<li>vim -M file: 以只读的方式打开文件，不可以强制保存；</li>
<li>vim -y num file: 将编辑窗口的大小设为num行；</li>
<li>vim + file: 从文件的末尾开始；</li>
<li>vim +num file: 从第num行开始；</li>
<li>vim +/string file: 打开file，并将光标停留在第一个找到的string上。</li>
<li>vim –remote file: 用已有的vim进程打开指定的文件。 如果你不想启用多个vim会话，这个很有用。但要注意， 如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了， 你可以用gvim –remote file在已有的gvim中打开文件。</li>
</ul>
<h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><ul>
<li>h或退格: 左移一个字符；</li>
<li>l或空格: 右移一个字符；</li>
<li>j: 下移一行；</li>
<li>k: 上移一行；</li>
<li>gj: 移动到一段内的下一行；</li>
<li>gk: 移动到一段内的上一行；</li>
<li>+或Enter: 把光标移至下一行第一个非空白字符。</li>
<li>-: 把光标移至上一行第一个非空白字符。</li>
<li>w: 前移一个单词，光标停在下一个单词开头；</li>
<li>W: 移动下一个单词开头，但忽略一些标点；</li>
<li>e: 前移一个单词，光标停在下一个单词末尾；</li>
<li>E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点；</li>
<li>b: 后移一个单词，光标停在上一个单词开头；</li>
<li>B: 移动到上一个单词开头，忽略一些标点；</li>
<li>ge: 后移一个单词，光标停在上一个单词末尾；</li>
<li>gE: 同 ge ，不过‘单词’包含单词相邻的标点。</li>
<li>(: 前移1句。</li>
<li>): 后移1句。</li>
<li>{: 前移1段。</li>
<li>}: 后移1段。</li>
<li>fc: 把光标移到同一行的下一个c字符处</li>
<li>Fc: 把光标移到同一行的上一个c字符处</li>
<li>tc: 把光标移到同一行的下一个c字符前</li>
<li>Tc: 把光标移到同一行的上一个c字符后</li>
<li>;: 配合f &amp; t使用，重复一次</li>
<li>,: 配合f &amp; t使用，反向重复一次</li>
</ul>
<p>上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符。</p>
<ul>
<li>0: 移动到行首。</li>
<li>g0: 移到光标所在屏幕行行首。</li>
<li>^: 移动到本行第一个非空白字符。</li>
<li>g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。</li>
<li>$: 移动到行尾。</li>
<li>g$: 移动光标所在屏幕行行尾。</li>
<li>n|: 把光标移到递n列上。</li>
<li>nG: 到文件第n行。</li>
<li>:n<cr> 移动到第n行。</cr></li>
<li>:$<cr> 移动到最后一行。</cr></li>
<li>H: 把光标移到屏幕最顶端一行。</li>
<li>M: 把光标移到屏幕中间一行。</li>
<li>L: 把光标移到屏幕最底端一行。</li>
<li>gg: 到文件头部。</li>
<li>G: 到文件尾部。</li>
</ul>
<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><ul>
<li>m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。</li>
<li>m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。</li>
<li>`{a-z}: 移动到标记位置。</li>
<li>‘{a-z}: 移动到标记行的行首。</li>
<li>`{0-9}：回到上[2-10]次关闭vim时最后离开的位置。</li>
<li>``: 移动到上次编辑的位置。’’也可以，不过``精确到列，而’’精确到行 。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。</li>
<li>`”: 移动到上次离开的地方。</li>
<li>`.: 移动到最后改动的地方。</li>
<li>:marks 显示所有标记。</li>
<li>:delmarks a b – 删除标记a和b。</li>
<li>:delmarks a-c – 删除标记a、b和c。</li>
<li>:delmarks a c-f – 删除标记a、c、d、e、f。</li>
<li>:delmarks! – 删除当前缓冲区的所有标记。</li>
</ul>
<h3 id="翻屏"><a href="#翻屏" class="headerlink" title="翻屏"></a>翻屏</h3><ul>
<li>ctrl+f: 下翻一屏。</li>
<li>ctrl+b: 上翻一屏。</li>
<li>ctrl+d: 下翻半屏。</li>
<li>ctrl+u: 上翻半屏。</li>
<li>ctrl+e: 向下滚动一行。</li>
<li>ctrl+y: 向上滚动一行。</li>
<li>n%: 到文件n%的位置。</li>
<li>zz: 将当前行移动到屏幕中央。</li>
<li>zt: 将当前行移动到屏幕顶端。</li>
<li>zb: 将当前行移动到屏幕底端。</li>
</ul>
<h3 id="选中对象"><a href="#选中对象" class="headerlink" title="选中对象"></a>选中对象</h3><p>按v进入可视模式</p>
<ul>
<li>选中标签内对象，在标签上按vit</li>
<li>选中标签内对象（包括标签），在标签上按vat</li>
</ul>
]]></content>
      <categories>
        <category>Linux使用指南</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Nginx的安装</title>
    <url>/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>环境：阿里云ECS Centos7</p>
</blockquote>
<h2 id="1-下载源码包"><a href="#1-下载源码包" class="headerlink" title="1. 下载源码包"></a>1. 下载源码包</h2><p>路径一般选择/usr下</p>
<blockquote>
<p>wget -c <a href="https://nginx.org/download/nginx-1.16.1.tar.gz" target="_blank" rel="noopener">https://nginx.org/download/nginx-1.16.1.tar.gz</a></p>
</blockquote>
<h2 id="2-安装所需依赖"><a href="#2-安装所需依赖" class="headerlink" title="2. 安装所需依赖"></a>2. 安装所需依赖</h2><blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y gcc-c++ #编译器</span><br><span class="line">yum install -y pcre pcre-devel #正则表达式</span><br><span class="line">yum install -y zlib zlib-devel #压缩算法</span><br><span class="line">yum install -y openssl openssl-devel #如果使用HTTPS，需要安装OpenSSL</span><br></pre></td></tr></table></figure>
</blockquote>
<p>devel 包主要是供开发用，至少包括以下2个东西:</p>
<ol>
<li>头文件</li>
<li>链接库<br>有的还含有开发文档或演示代码。</li>
</ol>
<p>以 glib 和 glib-devel 为例:</p>
<p>如果你安装基于 glib 开发的程序，只需要安装 glib 包就行了。</p>
<p>但是如果你要编译使用了 glib 的源代码，则需要安装 glib-devel。</p>
<h2 id="3-编译安装"><a href="#3-编译安装" class="headerlink" title="3. 编译安装"></a>3. 编译安装</h2><p>命令讲解</p>
<p>来自于GNU的AUTOCONF和AUTOMAKE工具。</p>
<ol>
<li><p>./configure 是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。</p>
<blockquote>
<p>这一步一般用来生成  Makefile，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，比如代码:./configure  –prefix=/usr 意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin （而不是默认的  /usr/local/bin),资源文件就会安装在  /usr/share（而不是默认的/usr/local/share）。同时一些软件的配置文件你可以通过指定 –sys-config=  参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许  ./configure –help 察看详细的说明帮助。</p>
</blockquote>
</li>
</ol>
<p>　2. make 是用来编译的，它从Makefile中读取指令，然后编译。</p>
<p>　3. make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。</p>
<p>解压</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure>
</blockquote>
<p>执行configure脚本，生成Makefile文件。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure>
</blockquote>
<p>编译</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="4-运行"><a href="#4-运行" class="headerlink" title="4. 运行"></a>4. 运行</h2><p>进入默认安装目录/usr/local，会发现已经创建了一个名为nginx的文件夹。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx #运行</span><br><span class="line">./nginx -s quit 或 ./nginx -s stop #关闭nginx</span><br><span class="line">./nginx -s reload #重启</span><br></pre></td></tr></table></figure>
</blockquote>
<p>查看nginx进程</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux | grep nginx</span><br></pre></td></tr></table></figure>
</blockquote>
<p>设置开机启动</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/rc.local</span><br><span class="line"><span class="meta">#</span><span class="bash">在文件底部增加启动代码即可</span></span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="5-问题解决"><a href="#5-问题解决" class="headerlink" title="5. 问题解决"></a>5. 问题解决</h2><h3 id="问题场景1"><a href="#问题场景1" class="headerlink" title="问题场景1"></a>问题场景1</h3><p>服务器重启后，重启nginx时报错nginx: [error] open()  “/usr/local/nginx/logs/nginx.pid” failed (2: No such file or  directory)，进入到logs目录发现确实没有nginx.pid文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;</span><br><span class="line">.&#x2F;nginx -s reload</span><br><span class="line">ngx_http_fastdfs_set pid&#x3D;1412</span><br><span class="line">ngx_http_fastdfs_set pid&#x3D;1412</span><br><span class="line">ngx_http_fastdfs_set pid&#x3D;1412</span><br><span class="line">ngx_http_fastdfs_set pid&#x3D;1412</span><br><span class="line">nginx: [error] open() &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&quot; failed (2: No such file or directory)</span><br></pre></td></tr></table></figure>

<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>使用指定nginx.conf文件的方式重启nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p>还有一种可能就是nginx.conf的nginx.pid被注释了,将下图中pid前的#去掉,保存退出再次启动nginx。</p>
<p>此时去logs目录下查看发现nginx.pid文件已经生成了。</p>
<h3 id="问题场景2"><a href="#问题场景2" class="headerlink" title="问题场景2"></a>问题场景2</h3><p>ngnix配置完成后外网无法访问</p>
<h4 id="第一种可能"><a href="#第一种可能" class="headerlink" title="第一种可能"></a>第一种可能</h4><p>阿里云服务器安全组配置中未配置80端口的访问规则。配置完即可。</p>
<h4 id="第二种可能"><a href="#第二种可能" class="headerlink" title="第二种可能"></a>第二种可能</h4><p>如果配置完阿里云服务器安全组策略后依然不可以，则考虑是Linux防火墙的问题。</p>
<p>所以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ]# &#x2F;sbin&#x2F;iptables -I INPUT -p tcp --dport 80 -j ACCEPT  </span><br><span class="line">[root@localhost ]# &#x2F;etc&#x2F;init.d&#x2F;iptables save  </span><br><span class="line">[root@localhost ]# &#x2F;etc&#x2F;init.d&#x2F;iptables restart</span><br></pre></td></tr></table></figure>

<p> 查找防火墙的文件命令：</p>
<p>vim /etc/sysconfig/iptables</p>
<p>打开文件之后会有：-A INPUT -p -tcp -m –dport 80 -j ACCEPT 此为打开了80端口</p>
<p>修改之后重启：service iptables restart</p>
<blockquote>
<p>Centos7中进行上述操作会报错，错误及解决方案如下</p>
</blockquote>
<p>报错：</p>
<p>Redirecting to /bin/systemctl restart iptables.service<br>Failed to restart iptables.service: Unit not found.</p>
<p>原因是因为CentOS7 里面是用 firewalld (相关介绍介绍请点击)来管理防火墙的。</p>
<ol>
<li><p>执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示FirewallD is not running，如下图所示。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/7dd98d1001e939013391d96372ec54e737d196df.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
<li><p>通过systemctl status firewalld查看firewalld状态，发现当前是dead状态，即防火墙未开启。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/55e736d12f2eb93882fe2eafdc628535e4dd6fdf.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
<li><p>通过systemctl start firewalld开启防火墙，没有任何提示即开启成功。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/e61190ef76c6a7efec9afc7bf4faaf51f3de662a.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
<li><p>再次通过systemctl status firewalld查看firewalld状态，显示running即已开启了。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/503d269759ee3d6d9f44d3964a166d224e4adee9.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
<li><p>如果要关闭防火墙设置，可能通过systemctl stop firewalld这条指令来关闭该功能。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/2e2eb9389b504fc2cecce458ecdde71191ef6ddf.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
<li><p>再次执行执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示success，表示设置成功，这样就可以继续后面的设置了。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/42166d224f4a20a4969c689a99529822730ed0e9.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
</ol>
<p>添加80端口为允许：</p>
<p>firewall-cmd –zone=public –add-port=80/tcp –permanent （–permanent 没有此参数重启后失效）</p>
]]></content>
      <categories>
        <category>Ngnix</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程之ThreadLocal</title>
    <url>/2017/12/24/2017-12-25-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal/</url>
    <content><![CDATA[<blockquote>
<p>ThreadLocal - 线程本地变量。顾名思义，ThreadLocal提供了线程内存储变量的能力，这些变量的不同之处在于针对不同的线程，它们各自读取的变量是对应于当前线程的，这些线程持有独立的变量副本，互不影响。通过get和set方法就可以得到当前线程对应的值。</p>
<p>Spring声明式事务的重要实现基础就是ThreadLocal。</p>
</blockquote>
<h2 id="由线程不安全的SimpleDateFormat说起"><a href="#由线程不安全的SimpleDateFormat说起" class="headerlink" title="由线程不安全的SimpleDateFormat说起"></a>由线程不安全的SimpleDateFormat说起</h2><p>SimpleDateFormat是JDK提供的一个常用的日期格式化类，这个类不是线程安全的。如果在日期工具类中，将SimpleDateFormat初始化为一个静态变量以防止多次初始化，那么在并发情况下，调用方法进行格式化的结果可能会出现错误，甚至抛出异常。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>使用局部变量。局部变量是线程私有的，也就不存在线程安全问题。但这样每次调用时都需要初始化SimpleDateFormat，有性能开销。</li>
<li>方法加同步锁synchronized。同步有性能开销，性能会受一定影响。</li>
<li>使用ThreadLocal。阿里巴巴开发手册中推荐使用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadLocal解决方案代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明静态变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; DATE_FORMAT_TL = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">DateFormat df = DATE_FORMAT_TL.get();</span><br></pre></td></tr></table></figure>

<p>使用上述代码，SimpleDateFormat被放入ThreadLocal中，每个线程在调用DATE_FORMAT_TL.get()时，都会从自己的线程本地存储中取变量，如果没有，就会执行initialValue创建一份，并存储在当前线程的本地存储中，下次调用时，当前线程可直接从本地存储中取出已经初始化好的SimpleDateFormat。</p>
<h2 id="与局部变量的区别-聊聊应用场景"><a href="#与局部变量的区别-聊聊应用场景" class="headerlink" title="与局部变量的区别 - 聊聊应用场景"></a>与局部变量的区别 - 聊聊应用场景</h2><p>什么时候使用ThreadLocal呢？</p>
<p>很多人将ThreadLocal的作用单一理解为将一个变量变为线程私有的，从而保证线程安全性，这是片面的，因为想做到这一点的话，使用局部变量就够了。局部变量存在于栈上，天生就是线程私有的，并且用起来还简单。</p>
<p>他们是有很大区别的。</p>
<p>首先，他们的生命周期不同，ThreadLocal的生命周期与线程相同（一般情况下，特殊情况在后面内存泄露一节会讨论），而局部变量的生命周期短的多，方法调用一结束，局部变量就在栈上销毁了。因此ThreadLocal既可以保证变量操作的线程安全性，也保证了同一线程在其生命周期内访问到的ThreadLocal是相同的，这也是SimpleDateFormat中ThreadLocal方案优于其他方案的原因，因为针对当前线程只需创建一次就够了。</p>
<p>其次，局部变量只能应用于方法上，而ThreadLocal可以应用于类属性变量上。</p>
<p><strong>存储单个线程上下文信息</strong></p>
<p>Context类的实现方式之一。</p>
<p><strong>保证类变量的线程安全</strong></p>
<p>一般一个类的属性变量按照java内存模型的设计都属于共享内存（存放在堆中）。一旦涉及多线程编程。对这个变量的修改读取基本都是线程不安全。当然要想安全就要加锁synchonize 或者各种lock. 哪怕是号称线程安全的各种并发类比如ConcurrentHashMap。这种类说是线程安全只是针对ConcurrentHashMap自己的一次get 或者set操作。不意味着多次get set，或者一次get+set的操作。要想一整套get+set都是线程安全还是要加锁。</p>
<p>这时可以使用ThreadLocal，每个线程存储一个变量副本，保证线程安全性。</p>
<p><strong>简化参数传递</strong></p>
<blockquote>
<p>如果我想跟踪一个请求，从接收请求，处理到返回的整个流程，有没有好的办法?</p>
<p>这其实就是线程内共享数据的问题。</p>
</blockquote>
<p>Threadlocal 可以做到传递参数。这是ThreadLocal的一个功能。很多人可能不知道，因为Threadlocal 是线程本地变量，只要线程不销毁，就会一直存在，因此可以使用Threadlocal来跟踪传递参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="number">1</span> 定义一个类读写threadlocal变量</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadAttributes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadAttribues = <span class="keyword">new</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Map&lt;String, Object&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getThreadAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> threadAttribues.get().get(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">setThreadAttribute</span><span class="params">(String name, Object value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> threadAttribues.get().put(name, value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 在一个filter里写入request</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp,</span></span></span><br><span class="line"><span class="function"><span class="params">                        FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">                HttpServletResponse response = (HttpServletResponse) resp;</span><br><span class="line">               </span><br><span class="line">                ThreadAttributes.setThreadAttribute(<span class="string">"request"</span>, req);</span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 读取request</span><br><span class="line">HttpServletRequest request = (HttpServletRequest)ThreadAttributes.getThreadAttribute(<span class="string">"request"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>线程类Thread中有一个类属性，专门存放线程独立的变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal就是用来管理这个threadLocals属性的。也就是说我们对于<code>ThreadLocal</code>的get, set，remove的操作结果都是针对当前线程Thread实例的threadLocals存，取，删除操作。</p>
<p><img src="/2017/12/24/2017-12-25-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal/image-20200407160341549.png" alt="image"></p>
<p><strong>ThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个Entry数组，ThreadLocal确定了一个数组下标，而这个下标就是Entry的对应位置。</strong></p>
<h2 id="潜在的内存泄露风险"><a href="#潜在的内存泄露风险" class="headerlink" title="潜在的内存泄露风险"></a>潜在的内存泄露风险</h2><p><strong>Memory leak:内存泄漏，程序申请内存后，无法释放已申请的内存空间，内存泄漏的堆积终将导致内存溢出。</strong></p>
<h3 id="Java的引用类型"><a href="#Java的引用类型" class="headerlink" title="Java的引用类型"></a>Java的引用类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>回收时间</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>一直存活，除非GC Roots不可达</td>
<td>所有程序的场景，基本对象，自定义对象等</td>
</tr>
<tr>
<td>软引用</td>
<td>内存不足时会被回收</td>
<td>一般用在对内存非常敏感的资源上，用作缓存的场景比较多，例如：网页缓存、图片缓存</td>
</tr>
<tr>
<td>弱引用</td>
<td>只能存活到下一次GC前</td>
<td>生命周期很短的对象，例如ThreadLocal中的Key。</td>
</tr>
<tr>
<td>虚引用</td>
<td>随时会被回收， 创建了可能很快就会被回收</td>
<td>可能被JVM团队内部用来跟踪JVM的垃圾回收活动</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">* its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">* ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">* == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">* entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">* as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么在这里Entry的key要使用弱引用呢？</p>
<p>不妨反过来想想，如果使用强引用，当ThreadLocal对象（假设为ThreadLocal@123456）的引用（是一个强引用，指向ThreadLocal@123456）被回收了，ThreadLocalMap本身（线程对象中）依然还持有ThreadLocal@123456的强引用，如果没有手动删除这个key，则ThreadLocal@123456不会被回收，所以只要当前线程不消亡，ThreadLocalMap引用的那些对象就不会被回收，可以认为这导致Entry内存泄漏。</p>
<p>那使用弱引用的好处呢？</p>
<p>如果使用弱引用，那指向ThreadLocal@123456对象的引用就两个：TL_INT强引用，和ThreadLocalMap中Entry的弱引用。一旦TL_INT被回收，则指向ThreadLocal@123456的就只有弱引用了，在下次gc的时候，这个ThreadLocal@123456就会被回收。</p>
<p>那么问题来了，ThreadLocal@123456对象只是作为ThreadLocalMap的一个key而存在的，现在它被回收了，但是它对应的value并没有被回收，内存泄露依然存在！而且key被删了之后，变成了null，value更是无法被访问到了！针对这一问题，ThreadLocalMap类的设计本身已经有了这一问题的解决方案，那就是在每次get()/set()/remove()ThreadLocalMap中的值的时候，会自动清理key为null的value。如此一来，value也能被回收了。</p>
<p>既然对key使用弱引用，能使key自动回收，那为什么不对value使用弱引用？答案显而易见，假设往ThreadLocalMap里存了一个value，gc过后value便消失了，那就无法使用ThreadLocalMap来达到存储全线程变量的效果了。（但是再次访问该key的时候，依然能取到value，此时取得的value是该value的初始值。即在删除之后，如果再次访问，取到null，会重新调用初始化方法。）</p>
<p>所以我们总结了使用ThreadLocal时会发生内存泄漏的前提条件：</p>
<ol>
<li><p>ThreadLocal引用被设置为null，且后面没有set，get，remove操作。</p>
</li>
<li><p>线程一直运行，不停止。（线程池）</p>
</li>
<li><p>触发了垃圾回收。（Minor GC或Full GC）</p>
</li>
</ol>
<p>我们看到ThreadLocal出现内存泄漏条件还是很苛刻的，所以我们只要破坏其中一个条件就可以避免内存泄漏，但为了更好的避免这种情况的发生我们使用ThreadLocal时遵守以下两个小原则:</p>
<ol>
<li>ThreadLocal申明为private static final。<br>  Private与final 尽可能不让他人修改变更引用，<br>  Static 表示为类属性，只有在程序结束才会被回收。</li>
<li>ThreadLocal使用后务必调用remove方法。<br>   最简单有效的方法是使用后将其移除。</li>
</ol>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java阻塞队列 - DelayQueue（延迟队列）</title>
    <url>/2018/05/13/DelayQueue%EF%BC%88%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>一种由延迟元素组成的无边界阻塞队列，其中一个元素只有在其延迟过期时才能被接受。队列的头是最快过期的延迟元素。如果没有延迟过期，则没有head，poll将返回null。当元素的getDelay（TimeUnit.NANOSECONDS）方法返回的值小于或等于零时，将发生过期。即使使用take或poll不能删除未过期的元素，也可以将它们视为正常元素。例如，size方法返回过期和未过期元素的计数。此队列不允许空元素（null）。</p>
<p>这个类及其迭代器实现了集合和迭代器接口的所有可选方法。方法Iterator()中提供的迭代器不能保证以任何特定顺序遍历DelayQueue的元素。</p>
<p>这个类是Java集合框架的成员。</p>
<p>—- Doug Lea</p>
</blockquote>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在我们的业务中通常会有一些需求是这样的： </p>
<ol>
<li>淘宝订单业务:<code>下单之后如果三十分钟之内没有付款就自动取消订单</code>。</li>
<li>饿了吗订餐通知:<code>下单成功后60s之后给用户发送短信通知</code>。</li>
<li>缓存系统的设计，缓存中的对象，超过了空闲时间，需要从缓存中移出。</li>
<li>……</li>
</ol>
<p>这类业务我们可以总结出一个特点:需要延迟工作。 </p>
<p>DelayQueue可以满足这类需求。</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>首先，DelayQueue规则定了队列中的元素必须实现Delayed接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Thread leader = <span class="keyword">null</span>; <span class="comment">// 等待队头元素的线程</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由源码可以看出DelayQueue内部使用了优先级队列PriorityQueue来保存元素。当调用DelayQueue的offer方法时，把Delayed对象加入到优先队列q中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        q.offer(e);</span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123; <span class="comment">// 如果新加入的元素是最快过期的元素</span></span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal(); <span class="comment">//唤醒阻塞的消费者线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DelayQueue的take方法，把优先队列q的first拿出来（peek），如果没有达到延时阀值，则进行await处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 调用后一直阻塞直到获得锁,但是接受中断信号</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// for(;;)比while(true)生成的字节码指令更少，不占用寄存器，而且没有判断跳转</span></span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await(); <span class="comment">// 如果没有元素，直接阻塞</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS); <span class="comment">// 判断是否过期</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) <span class="comment">// 如果过期了，直接弹出队头</span></span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await(); <span class="comment">// 如果没过期，且已经有leader在等待队头元素，则继续阻塞等待,同时释放锁</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        available.awaitNanos(delay); <span class="comment">// 如果leader就是当前线程，则阻塞指定的延迟时间</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DelayQueue的线程安全性是由ReentrantLock保证的。线程进入方法后会先获取锁，如果获取不到，会阻塞直至获取，如果获取到了，就会继续操作，此时如果获取的元素未过期，则本线程阻塞，一旦阻塞就会释放当前线程持有的锁。</p>
<p>当一个线程成为leader时，它只等待下一个延迟过去，而其他线程则无限期地等待。leader线程必须在从 take() 或 poll(…) 返回之前向其他线程发出信号，除非其他线程在此期间成为引导线程。</p>
<h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><p>下面以一个简单的生产者-消费者的例子来展示DelayQueue的延时处理。我们将向一个延时队列中扔进一堆延迟时间不等的任务，然后单独开启一个线程从队列中消费数据。</p>
<p>任务对象必须实现Delayed接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> delayTime; <span class="comment">// 多久之后执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTime; <span class="comment">// 过期时间点</span></span><br><span class="line">    <span class="keyword">private</span> String taskName; <span class="comment">// 任务名称</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String taskName, <span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskName = taskName;</span><br><span class="line">        <span class="keyword">this</span>.delayTime = delayTime;</span><br><span class="line">        <span class="keyword">this</span>.expireTime = System.nanoTime() + TimeUnit.NANOSECONDS.convert(delayTime, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写比较方法，让队列中的元素按照过期时间来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> d = (<span class="keyword">this</span>.getDelay(TimeUnit.NANOSECONDS) - o.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">        <span class="keyword">return</span> d &gt; <span class="number">0</span> ? <span class="number">1</span> : d &lt; <span class="number">0</span> ? -<span class="number">1</span> :<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// return (int) d; 这里绝对不能使用强制转换，极易出现上限溢出后发生数据截断。导致最后排序结果不符合预期。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(<span class="keyword">this</span>.expireTime - System.nanoTime(), TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Task:"</span> + taskName + <span class="string">" [delayTime="</span> + delayTime + <span class="string">", expireTime="</span> + expireTime + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> DelayQueue&lt;Task&gt; taskQueue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">    Thread producer = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                taskQueue.put(<span class="keyword">new</span> Task(i + <span class="string">""</span>, i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    producer.start();</span><br><span class="line">    </span><br><span class="line">    Thread consumer = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="comment">// 消费队列中的过期元素，执行doAction</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Task task;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task = taskQueue.take();</span><br><span class="line">                    task.doAction();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    consumer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下，各个任务依次打印：</p>
<p><img src="/2018/05/13/DelayQueue%EF%BC%88%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%EF%BC%89/image-20200513171457561.png" alt="image-20200513171457561"></p>
<p>这里还有一个实现缓存的例子，链接如下：<br> <a href="https://link.jianshu.com?t=http://www.cnblogs.com/jobs/archive/2007/04/27/730255.html" target="_blank" rel="noopener">http://www.cnblogs.com/jobs/archive/2007/04/27/730255.html</a></p>
<h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><p>在实现Delayed接口时，重写compareTo()方法是很重要的，只有compareTo()方法没有问题，才能保证队列中元素是按过期时间排序的。如果不重写，则需要传入比较器。</p>
<p>DelayQueue中的元素可以通过remove方法移除，此时请保证equals与hashCode方法的正确性。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>阻塞队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security - 认证授权的基本概念</title>
    <url>/2018/02/01/Spring%20Security%20-%20%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="一、认证"><a href="#一、认证" class="headerlink" title="一、认证"></a>一、认证</h2><p><strong>认证就是判断一个用户身份是否合法的过程。</strong></p>
<p>认证是为了保护系统的隐私数据与资源，用户身份合法是访问资源的前提。例如，登陆QQ时，需要输入用户名和密码，这就是一个认证的过程。只有用户名、密码校验通过后，用户才能继续操作。</p>
<p>常见的认证方式有：用户名密码登录、二维码登录、短信登录、指纹认证等等。</p>
<h2 id="二、会话"><a href="#二、会话" class="headerlink" title="二、会话"></a>二、会话</h2><blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/计算机科学" target="_blank" rel="noopener">计算机科学</a>领域来说，尤其是在<a href="https://zh.wikipedia.org/wiki/计算机网络" target="_blank" rel="noopener">网络</a>领域，<strong>会话</strong>（<strong>session</strong>，Microsoft Windows 中文版译作<strong>工作阶段</strong>）是一种持久网络协议，在用户（或用户代理）端和服务器端之间创建关联，从而起到交换数据包的作用机制，session在<a href="https://zh.wikipedia.org/wiki/网络协议" target="_blank" rel="noopener">网络协议</a>（例如<a href="https://zh.wikipedia.org/wiki/Telnet" target="_blank" rel="noopener">telnet</a>或<a href="https://zh.wikipedia.org/wiki/FTP" target="_blank" rel="noopener">FTP</a>）中是非常重要的部分。</p>
<p>在不包含<a href="https://zh.wikipedia.org/wiki/会话层" target="_blank" rel="noopener">会话层</a>（例如<a href="https://zh.wikipedia.org/wiki/UDP" target="_blank" rel="noopener">UDP</a>）或者是无法长时间驻留<a href="https://zh.wikipedia.org/wiki/会话层" target="_blank" rel="noopener">会话层</a>（例如<a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP</a>）的传输协议中，会话的维持需要依靠在传输数据中的高级别程序。例如，在浏览器和远程主机之间的HTTP传输中，HTTP cookie就会被用来包含一些相关的信息，例如session ID，参数和权限信息等。</p>
<p>—- 来自维基百科</p>
</blockquote>
<p>在认证授权系统中，为了避免用户每一次操作都需要进行繁琐的认证，大都选择将用户的认证信息保存在会话中，使用会话来记录并保持当前用户的登录状态。这样用户只需在第一次登陆时进行认证，后续操作会自动从会话中取出用户认证信息，极大方便了用户的操作。</p>
<p>认证系统中，会话常见的实现方式有基于session的方式，基于token的方式等等。</p>
<h3 id="2-1-基于Session的认证"><a href="#2-1-基于Session的认证" class="headerlink" title="2.1 基于Session的认证"></a>2.1 基于Session的认证</h3><p>Session是一种服务器端的会话机制，被广泛应用于Web应用中。由于HTTP是一种无状态协议，所以当需要记录用户状态时，就需要用某种机制来识具体的用户，这个机制可以用Session实现。典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。这个数据可以保存在集群、数据库、文件中。</p>
<p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>
<p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
<h3 id="2-2-基于Token的认证"><a href="#2-2-基于Token的认证" class="headerlink" title="2.2 基于Token的认证"></a>2.2 基于Token的认证</h3><p>Token是用户登录成功后，服务端生成的一段包含了特殊信息的数字令牌。与Session相同，Token也会被返回到客户端，但客户端保存Token的方式更灵活，可以保存到Cookie中也可以存到Local Storage中。这样用户后续的访问会携带这个Token，服务器通过验证这个Token来判断用户的登录状态。</p>
<h3 id="2-3-两种方式的区别"><a href="#2-3-两种方式的区别" class="headerlink" title="2.3 两种方式的区别"></a>2.3 两种方式的区别</h3><p>除了上面提到的客户端保存认证信息的方式不同外，两种方式在服务器端的实现也是有很大差别的。</p>
<ul>
<li>基于Session的认证方式由Servlet规范制定，服务端需要存储Session信息，这会占用一定资源，而且在分布式场景下会带来一些问题，这个我们后续会提到。</li>
<li>基于Token的认证方式不需要服务端存储Token，并且不限制客户端的存储方式。万物互联的今天，越来越多类型的客户端需要接入系统，系统多是采用前后分离的方式实现，故使用Token更为合适。</li>
</ul>
<h2 id="三、授权"><a href="#三、授权" class="headerlink" title="三、授权"></a>三、授权</h2><h3 id="3-1-什么是授权"><a href="#3-1-什么是授权" class="headerlink" title="3.1 什么是授权"></a>3.1 什么是授权</h3><p>一个应用是由多个功能模块和无数的资源组成的，而这些功能和资源往往不会全部对用户开放，多是有条件、有选择的对用户开放。比如，百度网盘的很多功能是需要开通会员后才能使用的，这些功能就是由用户权限控制的。</p>
<p>授权位于认证之后，是为了更细粒度的控制用户对资源的访问。系统会根据用户的权限来控制用户对不同资源的访问。</p>
<h3 id="3-2-授权的数据模型"><a href="#3-2-授权的数据模型" class="headerlink" title="3.2 授权的数据模型"></a>3.2 授权的数据模型</h3><ul>
<li>Who，主体（Subject），一般指用户</li>
<li>What，资源（Resource），分为功能资源（系统菜单）和数据资源（商品信息）</li>
<li>How，权限（Permission），用户操作权限</li>
</ul>
<p>相关的数据模型（数据库表）如下：</p>
<p>主体（用户ID，帐号，密码，……）</p>
<p>资源（资源ID，资源名称，访问路径，……）</p>
<p>权限（权限ID，权限标识，权限名称，资源ID，……）</p>
<p>角色（角色ID，角色名称，……）</p>
<p>角色和权限关系表（角色ID，权限ID，……）</p>
<p>主体和角色关系表（用户ID，角色ID，……)</p>
<p><img src="/2018/02/01/Spring%20Security%20-%20%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E6%9D%83%E9%99%90%E8%A1%A8.png" alt></p>
<p>通常生产实践中会将资源和权限表合并为一张表，这样一共五张表。</p>
<h2 id="四、RBAC"><a href="#四、RBAC" class="headerlink" title="四、RBAC"></a>四、RBAC</h2><h3 id="4-1-基于角色的访问控制（Role-Based-Access-Control）"><a href="#4-1-基于角色的访问控制（Role-Based-Access-Control）" class="headerlink" title="4.1 基于角色的访问控制（Role-Based Access Control）"></a>4.1 基于角色的访问控制（Role-Based Access Control）</h3><p>判断逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.hasRole(<span class="string">"经理"</span>)) &#123;</span><br><span class="line">	查询人员();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上图查询人员功能所需的角色发生了变化，则需要修改判断逻辑代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.hasRole(<span class="string">"经理"</span>) || user.hasRole(<span class="string">"HR"</span>)) &#123;</span><br><span class="line">    查询人员();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦变化，需要修改源代码，扩展性较差。</p>
<h3 id="4-2-基于资源的访问控制（Resource-Based-Access-Control）"><a href="#4-2-基于资源的访问控制（Resource-Based-Access-Control）" class="headerlink" title="4.2 基于资源的访问控制（Resource-Based Access Control）"></a>4.2 基于资源的访问控制（Resource-Based Access Control）</h3><p>判断逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.hasPermission(<span class="string">"查询人员权限"</span>)) &#123;</span><br><span class="line">    查询人员();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：系统设计时定义好功能资源的权限标识，即使角色发生变化，也不会表现在代码上。可扩展性强。</p>
]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
        <tag>访问控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle下的分页查询</title>
    <url>/2017/12/30/2017-12-30-Oracle%E4%B8%8B%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="rownum与rowid"><a href="#rownum与rowid" class="headerlink" title="rownum与rowid"></a>rownum与rowid</h2><p>rownum与rowid都是伪列，并不存在于数据表结构定义中。</p>
<h3 id="rownum"><a href="#rownum" class="headerlink" title="rownum"></a>rownum</h3><p>rownum是逻辑上的伪列，是在获取查询结果集后再加上去的 （获取一条记录加一个rownum）。对符合条件的结果添加一个从1开始的序列号。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">rownum</span>,phone_no <span class="keyword">from</span> ur_user_info <span class="keyword">where</span> <span class="keyword">rownum</span> &lt; <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<p>rownum是动态的，先有查询结果，然后再给结果集添加上rownum。</p>
<p><strong>使用误区：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-----错误写法：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">rownum</span>, phone_no</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">rownum</span> rn , phone_no <span class="keyword">from</span> ur_user_info ) a</span><br><span class="line"> <span class="keyword">where</span> a.rownum &gt; <span class="number">5</span></span><br><span class="line">   <span class="keyword">and</span> a.rownum &lt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><strong>错误原因：</strong><br>当产生结果集时，oracle会产生一条rownum为1的记录，显然不符合where条件；那么就会产生第二条记录，同样rownum=1,也不符合记录；  一直下去，导致最后上述sql产生的结果集时空集。 </p>
<p><strong>应用场景</strong></p>
<ul>
<li>分页查询</li>
</ul>
<h3 id="rowid"><a href="#rowid" class="headerlink" title="rowid"></a>rowid</h3><p>ROWID是ORACLE中的一个重要的概念。用于定位数据库中一条记录的一个相对唯一地址值。通常情况下，该值在该行数据插入到数据库表时即被确定且唯一。ROWID它是一个伪列，它并不实际存在于表中。它是ORACLE在读取表中数据行时，根据每一行数据的物理地址信息编码而成的一个伪列。所以根据一行数据的ROWID能找到一行数据的物理地址信息。从而快速地定位到数据行。数据库的大多数操作都是通过ROWID来完成的，而且使用ROWID来进行单记录定位速度是最快的。</p>
<p>要理解索引，必须先搞清楚ROWID。</p>
<p>rowid并不会真正存在于表的data block中,但是他会存在于index当中，用来通过rowid来寻找表中的行数据。</p>
<p><strong>B-Tree索引</strong>的每个索引条目具有两个字段。第一个字段表示索引的键值，对于单列索引来说是一个值；而对于多列索引来说则是多个值组合在一起的。第二个字段表示键值所对应的记录行的ROWID。所以索引能加快查询速度。</p>
<p><strong>特点：</strong></p>
<p>rowid并未存储在表中，所以不支持增删改操作，只能用户查询。 </p>
<p><strong>应用场景</strong></p>
<ul>
<li><p>去重：当多条记录主键相同或者多条记录完全一致时，只需要留下一条记录。（账单表中出现多条一样的数据）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> bal_acctbook_info</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">rowid</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">min</span>(<span class="keyword">rowid</span>)</span><br><span class="line">                       <span class="keyword">from</span> bal_acctbook_info</span><br><span class="line">                      <span class="keyword">where</span> balance_id = <span class="string">'4012562452'</span></span><br><span class="line">                        <span class="keyword">and</span> op_time = <span class="string">'20171212111111'</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="分页查询的几种方式"><a href="#分页查询的几种方式" class="headerlink" title="分页查询的几种方式"></a>分页查询的几种方式</h2><h3 id="利用rownum"><a href="#利用rownum" class="headerlink" title="利用rownum"></a>利用rownum</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">ROWNUM</span> <span class="keyword">AS</span> rowno, t.*</span><br><span class="line">      <span class="keyword">FROM</span> emp t</span><br><span class="line">      <span class="keyword">WHERE</span> hire_date <span class="keyword">BETWEEN</span> <span class="keyword">TO_DATE</span>(<span class="string">'20060501'</span>, <span class="string">'yyyymmdd'</span>)</span><br><span class="line">          <span class="keyword">AND</span> <span class="keyword">TO_DATE</span>(<span class="string">'20060731'</span>, <span class="string">'yyyymmdd'</span>)</span><br><span class="line">        <span class="keyword">AND</span> <span class="keyword">ROWNUM</span> &lt;= (page)*page_size) table_alias</span><br><span class="line"><span class="keyword">WHERE</span> table_alias.rowno &gt;= (page<span class="number">-1</span>)*page_size;</span><br></pre></td></tr></table></figure>

<h3 id="利用分析函数row-number"><a href="#利用分析函数row-number" class="headerlink" title="利用分析函数row_number"></a>利用分析函数row_number</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> </span><br><span class="line">        (<span class="keyword">select</span> row_number()  <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> usenum <span class="keyword">desc</span>) rownumber, t.*</span><br><span class="line">           <span class="keyword">from</span> t_account t)</span><br><span class="line">        <span class="keyword">where</span> rownumber &gt;= <span class="number">10</span> <span class="keyword">and</span> rownumber &lt;= <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>两种方法在性能上差距并不大，并不会因为用了高级函数而提升性能。</p>
<h2 id="分页的坑"><a href="#分页的坑" class="headerlink" title="分页的坑"></a>分页的坑</h2><p>后台分页有一个不可避免的缺点，就是数据变化比较频繁会导致数据遗漏、重叠等，比如取完第1页后，后台删掉了第1页的全部数据，接下去取第2页（实际已经是之前的第3页），会漏掉原本的第2页数据。</p>
<h3 id="分页时，数据出现重复或者排序不稳定"><a href="#分页时，数据出现重复或者排序不稳定" class="headerlink" title="分页时，数据出现重复或者排序不稳定"></a>分页时，数据出现重复或者排序不稳定</h3><p>出现重复的原因：</p>
<p>分页时，如果没有使用order by，oracle不会进行任何排序操作，如果sql没有要求排序，oracle会顺序的从数据块中读取符合条件的数据返回到客户端。所以在没有使用排序sql的时候，分页返回的数据可能是按顺序的，也可能是杂乱无章的，这都取决与数据的存储位置。</p>
<p>在分页查询过程中，如果数据的物理位置发生了改变，就可能会引起分页数据重复的现象。 <strong>所以，要正确使用分页查询，sql语句中必须有排序条件。</strong></p>
<p>但是，在有排序条件的时候，仍然会出现数据重复的现象，这是为什么呢？<br>通过了解oracle的排序机理就会明白，出现这种情况的原因是因为排序列值的不唯一性。 Oracle这里使用的排序算法不具有稳定性，也就是说，对于键值相等的数据，这种算法完成排序后，不保证这些键值相等的数据保持排序前的顺序.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> row_.*, <span class="keyword">rownum</span> rownum_</span><br><span class="line">          <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> createtime) row_</span><br><span class="line">         <span class="keyword">where</span> <span class="keyword">rownum</span> &lt;= <span class="number">10</span>)</span><br><span class="line"> <span class="keyword">where</span> rownum_ &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>内层结果集如果加入排序字段，比如：CREATETIME（创建日期），会发现筛选出来的结果集并不稳定，这个跟Oracle的排序机理有关系。</p>
</blockquote>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>需要给sql加入排序唯一的排序字段。我们知道，排序时当有多个字段时，从左到右的排序方式进行排序，排在前面的优先级高，写法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> row_.*, <span class="keyword">rownum</span> rownum_</span><br><span class="line">          <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> createtime <span class="keyword">desc</span>, <span class="keyword">id</span> <span class="keyword">asc</span>) row_</span><br><span class="line">         <span class="keyword">where</span> <span class="keyword">rownum</span> &lt;= <span class="number">10</span>)</span><br><span class="line"> <span class="keyword">where</span> rownum_ &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>order by语句应当遵循条件唯一性原则，否则oracle不保证每次查询的结果集都相同。</li>
<li>分页时，sql语句中需要有排序条件。 并且，排序条件如果没有唯一性，那么必须在后边跟上一个唯一性的条件，比如主键。</li>
</ul>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库 - 事务隔离与数据库锁</title>
    <url>/2019/12/01/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/</url>
    <content><![CDATA[<h2 id="一、什么是事务？"><a href="#一、什么是事务？" class="headerlink" title="一、什么是事务？"></a>一、什么是事务？</h2><blockquote>
<p><strong>数据库事务</strong>（<strong>Transaction</strong>）是<a href="https://zh.wikipedia.org/wiki/数据库管理系统" target="_blank" rel="noopener">数据库管理系统</a>执行过程中的一个逻辑单位，由一个有限的<a href="https://zh.wikipedia.org/wiki/数据库" target="_blank" rel="noopener">数据库</a>操作序列构成。这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p>
<p>—- <em>来自wikipedia</em></p>
</blockquote>
<p>例子：某人要在商店使用<a href="https://zh.wikipedia.org/wiki/電子貨幣" target="_blank" rel="noopener">电子货币</a>购买100元的东西，当中至少包括两个操作：</p>
<ol>
<li>该人账户减少100元</li>
<li>商店账户增加100元</li>
</ol>
<p><strong>支持事务的数据库管理系统</strong>（<strong>transactional DBMS</strong>）就是要确保以上两个操作（整个“事务”）都能完成，或一起取消；否则就会出现100元平白消失或出现的情况。</p>
<p>在 MySQL 中，事务支持是在引擎层实现的。MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。</p>
<h3 id="事务的特性（ACID）"><a href="#事务的特性（ACID）" class="headerlink" title="事务的特性（ACID）"></a>事务的特性（ACID）</h3><ul>
<li><strong>原子性</strong><br>　　事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。 </li>
<li><strong>一致性</strong><br>　　 事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">数据结构</a>（如 B 树索引或双向链表）都必须是正确的。某些维护一致性的责任由应用程序开发人员承担，他们必须确保应用程序已强制所有已知的完整性约束。例如，当开发用于转帐的应用程序时，应避免在转帐过程中任意移动小数点。 </li>
<li><strong>隔离性</strong><br>　　由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。当事务可序列化时将获得最高的隔离级别。在此级别上，从一组可并行执行的事务获得的结果与通过连续运行每个事务所获得的结果相同。由于高度隔离会限制可并行执行的事务数，所以一些应用程序降低隔离级别以换取更大的吞吐量。  </li>
<li><strong>持久性</strong><br>　　 事务完成之后，它对于系统的影响是永久性的。</li>
</ul>
<h2 id="二、隔离性与隔离级别"><a href="#二、隔离性与隔离级别" class="headerlink" title="二、隔离性与隔离级别"></a>二、隔离性与隔离级别</h2><h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p>
<p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。</p>
<ul>
<li><strong>Read Uncommitted（读取未提交）</strong><br>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</li>
<li><strong>Read Committed（读取已提交）</strong><br>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</li>
<li><strong>Repeatable Read（可重读）</strong><br>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</li>
<li><strong>Serializable（可串行化）</strong><br>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</li>
</ul>
<p>由不同的隔离级别导致的问题如下：</p>
<ul>
<li><p><strong>脏读(Drity Read)</strong>：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>
</li>
<li><p><strong>不可重复读(Non-repeatable read)</strong>：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p>
</li>
<li><p><strong>幻读(Phantom Read)</strong>：在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
</li>
</ul>
<p>对应关系如图：</p>
<img src="http://dl.iteye.com/upload/picture/pic/72610/af5b9c1e-4517-3df2-ad62-af25d1672d12.jpg" alt="img" style="zoom:67%;">

<h3 id="事务隔离的实现（MySQL为例）"><a href="#事务隔离的实现（MySQL为例）" class="headerlink" title="事务隔离的实现（MySQL为例）"></a>事务隔离的实现（MySQL为例）</h3><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。我们可以看到在不同的隔离级别下，数据库行为是有所不同的。</p>
<p><strong>Oracle 数据库的默认隔离级别是“读提交”，而MySQL数据库的默认隔离级别是“可重复读”。</strong>因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”。</p>
<p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录：</p>
<img src="https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png" alt="img" style="zoom:50%;">

<p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。</p>
<p>同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？</p>
<p>答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。</p>
<p><strong>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</strong></p>
<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>
<p>在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p>
<h2 id="三、数据库锁"><a href="#三、数据库锁" class="headerlink" title="三、数据库锁"></a>三、数据库锁</h2><blockquote>
<p>数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p>
</blockquote>
<p>数据库中锁的种类有很多，根据不同的划分标准，可以分为不同的种类，也因此衍生出了各种关于锁的专业名词，如果没捋清这其中的关系，很容易陷入术语的漩涡，最后弄得一头雾水。</p>
<p>所以我在这里先摆张从网上找的关系图，先让大家对锁有个整体上的认识，不至于犯嘀咕。</p>
<img src="http://raw.githubusercontent.com/IMWYY/AboutMyself/master/picBed/Screenshot1520500121.png" alt="img" style="zoom:100%;">

<h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><p><strong>悲观锁</strong></p>
<p>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
<ol>
<li><p>使用悲观锁，我们必须关闭mysql数据库的自动提交属性，采用手动提交事务的方式，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。</p>
</li>
<li><p>需要注意的是，在事务中，只有SELECT … FOR UPDATE 或LOCK IN SHARE MODE 同一笔数据时会等待其它事务结束后才执行，一般SELECT … 则不受此影响。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)。</p>
</li>
<li><p>补充：MySQL中select…for update的Row Lock与Table Lock</p>
<p>使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认Row-Level Lock，所以只有明确地指定主键（或有索引的地方），MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。</p>
</li>
</ol>
<p><strong>乐观锁</strong></p>
<p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做（<strong>一般是回滚事务</strong>）。那么我们如何实现乐观锁呢，一般来说有以下2种方式：</p>
<ol>
<li>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</li>
<li>乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</li>
</ol>
<p><strong>总结：</strong></p>
<p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p>
<p>另外，高并发情况下个人认为乐观锁要好于悲观锁，因为悲观锁的机制使得各个线程等待时间过长，极其影响效率，乐观锁可以在一定程度上提高并发度。</p>
<h3 id="共享锁与排他锁"><a href="#共享锁与排他锁" class="headerlink" title="共享锁与排他锁"></a>共享锁与排他锁</h3><p>共享锁（又称<strong>读锁</strong>）、排它锁（又称<strong>写锁</strong>）。</p>
<p><strong>共享锁（S）</strong></p>
<ul>
<li><p>加锁与解锁：当一个事务执行select语句时，数据库系统会为这个事务分配一把共享锁，来锁定被查询的数据。在默认情况下，数据被读取后，数据库系统立即解除共享锁。例如，当一个事务执行查询“SELECT * FROM accounts”语句时，数据库系统首先锁定第一行，读取之后，解除对第一行的锁定，然后锁定第二行。这样，在一个事务读操作过程中，允许其他事务同时更新accounts表中未锁定的行。</p>
</li>
<li><p>兼容性：如果数据资源上放置了共享锁，还能再放置共享锁和更新锁。</p>
</li>
<li><p>并发性能：具有良好的并发性能，当数据被放置共享锁后，还可以再放置共享锁或更新锁。所以并发性能很好。</p>
</li>
</ul>
<p><strong>排他锁（X）</strong></p>
<ul>
<li><p>加锁与解锁：当一个事务执行insert、update、select … for update或delete语句时，数据库系统会自动对SQL语句操纵的数据资源使用独占锁。如果该数据资源已经有其他锁（任何锁）存在时，就无法对其再放置独占锁了。</p>
</li>
<li><p>兼容性：独占锁不能和其他锁兼容，如果数据资源上已经加了独占锁，就不能再放置其他的锁了。同样，如果数据资源上已经放置了其他锁，那么也就不能再放置独占锁了。</p>
</li>
<li><p>并发性能：最差。只允许一个事务访问锁定的数据，如果其他事务也需要访问该数据，就必须等待。</p>
</li>
</ul>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>知乎上有个解释十分形象，如下：</p>
<ol>
<li><p>在MySQL中有表锁，读锁锁表，会阻塞其他事务修改表数据。写锁锁表，会阻塞其他事务读和写。</p>
</li>
<li><p>InnoDB引擎又支持行锁，行锁分为共享锁，一个事务对一行的共享只读锁。排它锁，一个事务对一行的排他读写锁。</p>
</li>
<li><p>这两种类型的锁共存的问题。考虑这个例子：事务A锁住了表中的一行，让这一行只能读，不能写。之后，事务B申请整个表的写锁。如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。</p>
</li>
</ol>
<p>数据库要怎么判断这个冲突呢？</p>
<ul>
<li>step1：判断表是否已被其他事务用表锁锁表</li>
<li>step2：判断表中的每一行是否已被行锁锁住。</li>
</ul>
<p>注意step2，这样的判断方法效率实在不高，因为需要遍历整个表。于是就有了意向锁。在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。</p>
<p>在意向锁存在的情况下，上面的判断可以改成</p>
<ul>
<li>step1：不变</li>
<li>step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。</li>
</ul>
<p>注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。</p>
<h3 id="怎么减少行锁对性能的影响？"><a href="#怎么减少行锁对性能的影响？" class="headerlink" title="怎么减少行锁对性能的影响？"></a>怎么减少行锁对性能的影响？</h3><p>先给你举个例子。在下面的操作序列中，事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键。</p>
<img src="https://static001.geekbang.org/resource/image/51/10/51f501f718e420244b0a2ec2ce858710.jpg" alt="img" style="zoom:50%;">

<p>这个问题的结论取决于事务 A 在执行完两条 update 语句后，持有哪些锁，以及在什么时候释放。你可以验证一下：实际上事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。</p>
<p>知道了这个答案，你一定知道了事务 A 持有的两个记录的行锁，都是在 <strong>commit 的时候才释放的</strong>。</p>
<p>也就是说，<strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议</strong>。</p>
<p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，<strong>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</strong>。</p>
<h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。</p>
<img src="https://static001.geekbang.org/resource/image/4d/52/4d0eeec7b136371b79248a0aed005a52.jpg" alt="img" style="zoom:50%;">

<p>这时候，事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</li>
</ul>
<p>在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p>
<p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p>所以，正常情况下我们还是要采用第二种策略，即：<strong>主动死锁检测</strong>，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p>
<p>你可以想象一下这个过程：</p>
<p>每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。那如果是我们上面说到的所有事务都要更新同一行的场景呢？每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。</p>
<p>假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。根据上面的分析，我们来讨论一下，怎么解决由这种热点行更新导致的性能问题呢？问题的症结在于，死锁检测要耗费大量的 CPU 资源。</p>
<p><strong>解决方案</strong></p>
<ul>
<li><p>一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</p>
</li>
<li><p>另一个思路是控制并发度。根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有 10 个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有 600 个客户端，这样即使每个客户端控制到只有 5 个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到 3000。</p>
<p>因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。</p>
</li>
<li><p>可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成 0 的时候，代码要有特殊处理。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
