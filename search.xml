<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vim - 快捷键</title>
    <url>/2017/12/24/2017-12-24-Vim-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="Vim-快捷键"><a href="#Vim-快捷键" class="headerlink" title="Vim - 快捷键"></a>Vim - 快捷键</h1><h2 id="启动Vim"><a href="#启动Vim" class="headerlink" title="启动Vim"></a>启动Vim</h2><ul>
<li>vim -c cmd file: 在打开文件前，先执行指定的命令；</li>
<li>vim -r file: 恢复上次异常退出的文件；</li>
<li>vim -R file: 以只读的方式打开文件，但可以强制保存；</li>
<li>vim -M file: 以只读的方式打开文件，不可以强制保存；</li>
<li>vim -y num file: 将编辑窗口的大小设为num行；</li>
<li>vim + file: 从文件的末尾开始；</li>
<li>vim +num file: 从第num行开始；</li>
<li>vim +/string file: 打开file，并将光标停留在第一个找到的string上。</li>
<li>vim –remote file: 用已有的vim进程打开指定的文件。 如果你不想启用多个vim会话，这个很有用。但要注意， 如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了， 你可以用gvim –remote file在已有的gvim中打开文件。</li>
</ul>
<h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><ul>
<li>h或退格: 左移一个字符；</li>
<li>l或空格: 右移一个字符；</li>
<li>j: 下移一行；</li>
<li>k: 上移一行；</li>
<li>gj: 移动到一段内的下一行；</li>
<li>gk: 移动到一段内的上一行；</li>
<li>+或Enter: 把光标移至下一行第一个非空白字符。</li>
<li>-: 把光标移至上一行第一个非空白字符。</li>
<li>w: 前移一个单词，光标停在下一个单词开头；</li>
<li>W: 移动下一个单词开头，但忽略一些标点；</li>
<li>e: 前移一个单词，光标停在下一个单词末尾；</li>
<li>E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点；</li>
<li>b: 后移一个单词，光标停在上一个单词开头；</li>
<li>B: 移动到上一个单词开头，忽略一些标点；</li>
<li>ge: 后移一个单词，光标停在上一个单词末尾；</li>
<li>gE: 同 ge ，不过‘单词’包含单词相邻的标点。</li>
<li>(: 前移1句。</li>
<li>): 后移1句。</li>
<li>{: 前移1段。</li>
<li>}: 后移1段。</li>
<li>fc: 把光标移到同一行的下一个c字符处</li>
<li>Fc: 把光标移到同一行的上一个c字符处</li>
<li>tc: 把光标移到同一行的下一个c字符前</li>
<li>Tc: 把光标移到同一行的上一个c字符后</li>
<li>;: 配合f &amp; t使用，重复一次</li>
<li>,: 配合f &amp; t使用，反向重复一次</li>
</ul>
<p>上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符。</p>
<ul>
<li>0: 移动到行首。</li>
<li>g0: 移到光标所在屏幕行行首。</li>
<li>^: 移动到本行第一个非空白字符。</li>
<li>g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。</li>
<li>$: 移动到行尾。</li>
<li>g$: 移动光标所在屏幕行行尾。</li>
<li>n|: 把光标移到递n列上。</li>
<li>nG: 到文件第n行。</li>
<li>:n<cr> 移动到第n行。</cr></li>
<li>:$<cr> 移动到最后一行。</cr></li>
<li>H: 把光标移到屏幕最顶端一行。</li>
<li>M: 把光标移到屏幕中间一行。</li>
<li>L: 把光标移到屏幕最底端一行。</li>
<li>gg: 到文件头部。</li>
<li>G: 到文件尾部。</li>
</ul>
<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><ul>
<li>m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。</li>
<li>m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。</li>
<li>`{a-z}: 移动到标记位置。</li>
<li>‘{a-z}: 移动到标记行的行首。</li>
<li>`{0-9}：回到上[2-10]次关闭vim时最后离开的位置。</li>
<li>``: 移动到上次编辑的位置。’’也可以，不过``精确到列，而’’精确到行 。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。</li>
<li>`”: 移动到上次离开的地方。</li>
<li>`.: 移动到最后改动的地方。</li>
<li>:marks 显示所有标记。</li>
<li>:delmarks a b – 删除标记a和b。</li>
<li>:delmarks a-c – 删除标记a、b和c。</li>
<li>:delmarks a c-f – 删除标记a、c、d、e、f。</li>
<li>:delmarks! – 删除当前缓冲区的所有标记。</li>
</ul>
<h3 id="翻屏"><a href="#翻屏" class="headerlink" title="翻屏"></a>翻屏</h3><ul>
<li>ctrl+f: 下翻一屏。</li>
<li>ctrl+b: 上翻一屏。</li>
<li>ctrl+d: 下翻半屏。</li>
<li>ctrl+u: 上翻半屏。</li>
<li>ctrl+e: 向下滚动一行。</li>
<li>ctrl+y: 向上滚动一行。</li>
<li>n%: 到文件n%的位置。</li>
<li>zz: 将当前行移动到屏幕中央。</li>
<li>zt: 将当前行移动到屏幕顶端。</li>
<li>zb: 将当前行移动到屏幕底端。</li>
</ul>
<h3 id="选中对象"><a href="#选中对象" class="headerlink" title="选中对象"></a>选中对象</h3><p>按v进入可视模式</p>
<ul>
<li>选中标签内对象，在标签上按vit</li>
<li>选中标签内对象（包括标签），在标签上按vat</li>
</ul>
]]></content>
      <categories>
        <category>Linux使用指南</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-事务传播级别</title>
    <url>/2017/01/05/2017-01-05-Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h2 id="一、TransactionPropagation"><a href="#一、TransactionPropagation" class="headerlink" title="一、TransactionPropagation"></a>一、TransactionPropagation</h2><ul>
<li>PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</li>
<li>PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。</li>
<li>PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。</li>
<li>PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li>PROPAGATION_NESTED – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。<br>前六个策略类似于EJB CMT，第七个（PROPAGATION_NESTED）是Spring所提供的一个特殊变量。<br>它要求事务管理器或者使用JDBC 3.0 Savepoint API提供嵌套事务行为（如Spring的DataSourceTransactionManager）</li>
</ul>
<p>其中对于PROPAGATION_REQUIRES_NEW与PROPAGATION_NESTED的理解上有些类似，关键在于嵌套事务的理解。</p>
<p>来看一下网上大神对Juergen Hoeller表述的翻译：</p>
<blockquote>
<p>PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。</p>
<p>另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务,  它是已经存在事务的一个真正的子事务. 嵌套事务开始执行时,  它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交. </p>
</blockquote>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serviceA.methodA() &#123;</span><br><span class="line">	doSomethingA();</span><br><span class="line">	serviceB.methodB();</span><br><span class="line">	doSomethingB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2017/01/05/2017-01-05-Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%BA%A7%E5%88%AB/image-20200428135125561.png" alt="image"></p>
<h2 id="二、Spring事务之UnexpectedRollbackException异常"><a href="#二、Spring事务之UnexpectedRollbackException异常" class="headerlink" title="二、Spring事务之UnexpectedRollbackException异常"></a>二、Spring事务之UnexpectedRollbackException异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serviceA.methodA()</span><br><span class="line">&#123;  </span><br><span class="line">doSomethingA();  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">            serviceB.methodB&#123;&#125;; <span class="comment">//这里面有异常标记为回滚, doSetRollbackOnly(status);  </span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;  </span><br><span class="line">               <span class="comment">//捕获异常转到commit时，由于已经标记为要回滚， 回滚并抛出新异常     </span></span><br><span class="line">       &#125;         </span><br><span class="line">   doSomethingB();  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>因为在ServiceA和ServiceB中的@Transactional  propagation都采用的默认值：REQUREID。根据我们前面讲过的REQUIRED特性，当ServiceA调用ServiceB的时候，他们是处于同一个transaction中。</p>
<p>当ServiceB中抛出了一个异常以后，ServiceB会把当前的transaction标记为需要rollback。但是ServiceA中捕获了这个异常，并进行了处理，认为当前transaction应该正常commit。但因为methodB有异常事务，已经被标记为回滚，在commit时spring会判断回滚标志，若检测到存在回滚标记， 则回滚事务并抛出UnexpectedRollbackException异常。</p>
]]></content>
      <categories>
        <category>Spring JPA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring JPA</tag>
        <tag>数据库</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle下的分页查询</title>
    <url>/2017/12/30/2017-12-30-Oracle%E4%B8%8B%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="rownum与rowid"><a href="#rownum与rowid" class="headerlink" title="rownum与rowid"></a>rownum与rowid</h2><p>rownum与rowid都是伪列，并不存在于数据表结构定义中。</p>
<h3 id="rownum"><a href="#rownum" class="headerlink" title="rownum"></a>rownum</h3><p>rownum是逻辑上的伪列，是在获取查询结果集后再加上去的 （获取一条记录加一个rownum）。对符合条件的结果添加一个从1开始的序列号。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">rownum</span>,phone_no <span class="keyword">from</span> ur_user_info <span class="keyword">where</span> <span class="keyword">rownum</span> &lt; <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<p>rownum是动态的，先有查询结果，然后再给结果集添加上rownum。</p>
<p><strong>使用误区：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-----错误写法：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">rownum</span>, phone_no</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">rownum</span> rn , phone_no <span class="keyword">from</span> ur_user_info ) a</span><br><span class="line"> <span class="keyword">where</span> a.rownum &gt; <span class="number">5</span></span><br><span class="line">   <span class="keyword">and</span> a.rownum &lt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><strong>错误原因：</strong><br>当产生结果集时，oracle会产生一条rownum为1的记录，显然不符合where条件；那么就会产生第二条记录，同样rownum=1,也不符合记录；  一直下去，导致最后上述sql产生的结果集时空集。 </p>
<p><strong>应用场景</strong></p>
<ul>
<li>分页查询</li>
</ul>
<h3 id="rowid"><a href="#rowid" class="headerlink" title="rowid"></a>rowid</h3><p>ROWID是ORACLE中的一个重要的概念。用于定位数据库中一条记录的一个相对唯一地址值。通常情况下，该值在该行数据插入到数据库表时即被确定且唯一。ROWID它是一个伪列，它并不实际存在于表中。它是ORACLE在读取表中数据行时，根据每一行数据的物理地址信息编码而成的一个伪列。所以根据一行数据的ROWID能找到一行数据的物理地址信息。从而快速地定位到数据行。数据库的大多数操作都是通过ROWID来完成的，而且使用ROWID来进行单记录定位速度是最快的。</p>
<p>要理解索引，必须先搞清楚ROWID。</p>
<p>rowid并不会真正存在于表的data block中,但是他会存在于index当中，用来通过rowid来寻找表中的行数据。</p>
<p><strong>B-Tree索引</strong>的每个索引条目具有两个字段。第一个字段表示索引的键值，对于单列索引来说是一个值；而对于多列索引来说则是多个值组合在一起的。第二个字段表示键值所对应的记录行的ROWID。所以索引能加快查询速度。</p>
<p><strong>特点：</strong></p>
<p>rowid并未存储在表中，所以不支持增删改操作，只能用户查询。 </p>
<p><strong>应用场景</strong></p>
<ul>
<li><p>去重：当多条记录主键相同或者多条记录完全一致时，只需要留下一条记录。（账单表中出现多条一样的数据）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> bal_acctbook_info</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">rowid</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">min</span>(<span class="keyword">rowid</span>)</span><br><span class="line">                       <span class="keyword">from</span> bal_acctbook_info</span><br><span class="line">                      <span class="keyword">where</span> balance_id = <span class="string">'4012562452'</span></span><br><span class="line">                        <span class="keyword">and</span> op_time = <span class="string">'20171212111111'</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="分页查询的几种方式"><a href="#分页查询的几种方式" class="headerlink" title="分页查询的几种方式"></a>分页查询的几种方式</h2><h3 id="利用rownum"><a href="#利用rownum" class="headerlink" title="利用rownum"></a>利用rownum</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">ROWNUM</span> <span class="keyword">AS</span> rowno, t.*</span><br><span class="line">      <span class="keyword">FROM</span> emp t</span><br><span class="line">      <span class="keyword">WHERE</span> hire_date <span class="keyword">BETWEEN</span> <span class="keyword">TO_DATE</span>(<span class="string">'20060501'</span>, <span class="string">'yyyymmdd'</span>)</span><br><span class="line">          <span class="keyword">AND</span> <span class="keyword">TO_DATE</span>(<span class="string">'20060731'</span>, <span class="string">'yyyymmdd'</span>)</span><br><span class="line">        <span class="keyword">AND</span> <span class="keyword">ROWNUM</span> &lt;= (page)*page_size) table_alias</span><br><span class="line"><span class="keyword">WHERE</span> table_alias.rowno &gt;= (page<span class="number">-1</span>)*page_size;</span><br></pre></td></tr></table></figure>

<h3 id="利用分析函数row-number"><a href="#利用分析函数row-number" class="headerlink" title="利用分析函数row_number"></a>利用分析函数row_number</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> </span><br><span class="line">        (<span class="keyword">select</span> row_number()  <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> usenum <span class="keyword">desc</span>) rownumber, t.*</span><br><span class="line">           <span class="keyword">from</span> t_account t)</span><br><span class="line">        <span class="keyword">where</span> rownumber &gt;= <span class="number">10</span> <span class="keyword">and</span> rownumber &lt;= <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>两种方法在性能上差距并不大，并不会因为用了高级函数而提升性能。</p>
<h2 id="分页的坑"><a href="#分页的坑" class="headerlink" title="分页的坑"></a>分页的坑</h2><p>后台分页有一个不可避免的缺点，就是数据变化比较频繁会导致数据遗漏、重叠等，比如取完第1页后，后台删掉了第1页的全部数据，接下去取第2页（实际已经是之前的第3页），会漏掉原本的第2页数据。</p>
<h3 id="分页时，数据出现重复或者排序不稳定"><a href="#分页时，数据出现重复或者排序不稳定" class="headerlink" title="分页时，数据出现重复或者排序不稳定"></a>分页时，数据出现重复或者排序不稳定</h3><p>出现重复的原因：</p>
<p>分页时，如果没有使用order by，oracle不会进行任何排序操作，如果sql没有要求排序，oracle会顺序的从数据块中读取符合条件的数据返回到客户端。所以在没有使用排序sql的时候，分页返回的数据可能是按顺序的，也可能是杂乱无章的，这都取决与数据的存储位置。</p>
<p>在分页查询过程中，如果数据的物理位置发生了改变，就可能会引起分页数据重复的现象。 <strong>所以，要正确使用分页查询，sql语句中必须有排序条件。</strong></p>
<p>但是，在有排序条件的时候，仍然会出现数据重复的现象，这是为什么呢？<br>通过了解oracle的排序机理就会明白，出现这种情况的原因是因为排序列值的不唯一性。 Oracle这里使用的排序算法不具有稳定性，也就是说，对于键值相等的数据，这种算法完成排序后，不保证这些键值相等的数据保持排序前的顺序.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> row_.*, <span class="keyword">rownum</span> rownum_</span><br><span class="line">          <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> createtime) row_</span><br><span class="line">         <span class="keyword">where</span> <span class="keyword">rownum</span> &lt;= <span class="number">10</span>)</span><br><span class="line"> <span class="keyword">where</span> rownum_ &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>内层结果集如果加入排序字段，比如：CREATETIME（创建日期），会发现筛选出来的结果集并不稳定，这个跟Oracle的排序机理有关系。</p>
</blockquote>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>需要给sql加入排序唯一的排序字段。我们知道，排序时当有多个字段时，从左到右的排序方式进行排序，排在前面的优先级高，写法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> row_.*, <span class="keyword">rownum</span> rownum_</span><br><span class="line">          <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> createtime <span class="keyword">desc</span>, <span class="keyword">id</span> <span class="keyword">asc</span>) row_</span><br><span class="line">         <span class="keyword">where</span> <span class="keyword">rownum</span> &lt;= <span class="number">10</span>)</span><br><span class="line"> <span class="keyword">where</span> rownum_ &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>order by语句应当遵循条件唯一性原则，否则oracle不保证每次查询的结果集都相同。</li>
<li>分页时，sql语句中需要有排序条件。 并且，排序条件如果没有唯一性，那么必须在后边跟上一个唯一性的条件，比如主键。</li>
</ul>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程之ThreadLocal</title>
    <url>/2017/12/24/2017-12-25-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal/</url>
    <content><![CDATA[<blockquote>
<p>ThreadLocal - 线程本地变量。顾名思义，ThreadLocal提供了线程内存储变量的能力，这些变量的不同之处在于针对不同的线程，它们各自读取的变量是对应于当前线程的，这些线程持有独立的变量副本，互不影响。通过get和set方法就可以得到当前线程对应的值。</p>
<p>Spring声明式事务的重要实现基础就是ThreadLocal。</p>
</blockquote>
<h2 id="由线程不安全的SimpleDateFormat说起"><a href="#由线程不安全的SimpleDateFormat说起" class="headerlink" title="由线程不安全的SimpleDateFormat说起"></a>由线程不安全的SimpleDateFormat说起</h2><p>SimpleDateFormat是JDK提供的一个常用的日期格式化类，这个类不是线程安全的。如果在日期工具类中，将SimpleDateFormat初始化为一个静态变量以防止多次初始化，那么在并发情况下，调用方法进行格式化的结果可能会出现错误，甚至抛出异常。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>使用局部变量。局部变量是线程私有的，也就不存在线程安全问题。但这样每次调用时都需要初始化SimpleDateFormat，有性能开销。</li>
<li>方法加同步锁synchronized。同步有性能开销，性能会受一定影响。</li>
<li>使用ThreadLocal。阿里巴巴开发手册中推荐使用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadLocal解决方案代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明静态变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; DATE_FORMAT_TL = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">DateFormat df = DATE_FORMAT_TL.get();</span><br></pre></td></tr></table></figure>

<p>使用上述代码，SimpleDateFormat被放入ThreadLocal中，每个线程在调用DATE_FORMAT_TL.get()时，都会从自己的线程本地存储中取变量，如果没有，就会执行initialValue创建一份，并存储在当前线程的本地存储中，下次调用时，当前线程可直接从本地存储中取出已经初始化好的SimpleDateFormat。</p>
<h2 id="与局部变量的区别-聊聊应用场景"><a href="#与局部变量的区别-聊聊应用场景" class="headerlink" title="与局部变量的区别 - 聊聊应用场景"></a>与局部变量的区别 - 聊聊应用场景</h2><p>什么时候使用ThreadLocal呢？</p>
<p>很多人将ThreadLocal的作用单一理解为将一个变量变为线程私有的，从而保证线程安全性，这是片面的，因为想做到这一点的话，使用局部变量就够了。局部变量存在于栈上，天生就是线程私有的，并且用起来还简单。</p>
<p>他们是有很大区别的。</p>
<p>首先，他们的生命周期不同，ThreadLocal的生命周期与线程相同（一般情况下，特殊情况在后面内存泄露一节会讨论），而局部变量的生命周期短的多，方法调用一结束，局部变量就在栈上销毁了。因此ThreadLocal既可以保证变量操作的线程安全性，也保证了同一线程在其生命周期内访问到的ThreadLocal是相同的，这也是SimpleDateFormat中ThreadLocal方案优于其他方案的原因，因为针对当前线程只需创建一次就够了。</p>
<p>其次，局部变量只能应用于方法上，而ThreadLocal可以应用于类属性变量上。</p>
<p><strong>存储单个线程上下文信息</strong></p>
<p>Context类的实现方式之一。</p>
<p><strong>保证类变量的线程安全</strong></p>
<p>一般一个类的属性变量按照java内存模型的设计都属于共享内存（存放在堆中）。一旦涉及多线程编程。对这个变量的修改读取基本都是线程不安全。当然要想安全就要加锁synchonize 或者各种lock. 哪怕是号称线程安全的各种并发类比如ConcurrentHashMap。这种类说是线程安全只是针对ConcurrentHashMap自己的一次get 或者set操作。不意味着多次get set，或者一次get+set的操作。要想一整套get+set都是线程安全还是要加锁。</p>
<p>这时可以使用ThreadLocal，每个线程存储一个变量副本，保证线程安全性。</p>
<p><strong>简化参数传递</strong></p>
<blockquote>
<p>如果我想跟踪一个请求，从接收请求，处理到返回的整个流程，有没有好的办法?</p>
<p>这其实就是线程内共享数据的问题。</p>
</blockquote>
<p>Threadlocal 可以做到传递参数。这是ThreadLocal的一个功能。很多人可能不知道，因为Threadlocal 是线程本地变量，只要线程不销毁，就会一直存在，因此可以使用Threadlocal来跟踪传递参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="number">1</span> 定义一个类读写threadlocal变量</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadAttributes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadAttribues = <span class="keyword">new</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Map&lt;String, Object&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getThreadAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> threadAttribues.get().get(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">setThreadAttribute</span><span class="params">(String name, Object value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> threadAttribues.get().put(name, value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 在一个filter里写入request</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp,</span></span></span><br><span class="line"><span class="function"><span class="params">                        FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">                HttpServletResponse response = (HttpServletResponse) resp;</span><br><span class="line">               </span><br><span class="line">                ThreadAttributes.setThreadAttribute(<span class="string">"request"</span>, req);</span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 读取request</span><br><span class="line">HttpServletRequest request = (HttpServletRequest)ThreadAttributes.getThreadAttribute(<span class="string">"request"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>线程类Thread中有一个类属性，专门存放线程独立的变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal就是用来管理这个threadLocals属性的。也就是说我们对于<code>ThreadLocal</code>的get, set，remove的操作结果都是针对当前线程Thread实例的threadLocals存，取，删除操作。</p>
<p><img src="/2017/12/24/2017-12-25-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal/image-20200407160341549.png" alt="image"></p>
<p><strong>ThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个Entry数组，ThreadLocal确定了一个数组下标，而这个下标就是Entry的对应位置。</strong></p>
<h2 id="潜在的内存泄露风险"><a href="#潜在的内存泄露风险" class="headerlink" title="潜在的内存泄露风险"></a>潜在的内存泄露风险</h2><p><strong>Memory leak:内存泄漏，程序申请内存后，无法释放已申请的内存空间，内存泄漏的堆积终将导致内存溢出。</strong></p>
<h3 id="Java的引用类型"><a href="#Java的引用类型" class="headerlink" title="Java的引用类型"></a>Java的引用类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>回收时间</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>一直存活，除非GC Roots不可达</td>
<td>所有程序的场景，基本对象，自定义对象等</td>
</tr>
<tr>
<td>软引用</td>
<td>内存不足时会被回收</td>
<td>一般用在对内存非常敏感的资源上，用作缓存的场景比较多，例如：网页缓存、图片缓存</td>
</tr>
<tr>
<td>弱引用</td>
<td>只能存活到下一次GC前</td>
<td>生命周期很短的对象，例如ThreadLocal中的Key。</td>
</tr>
<tr>
<td>虚引用</td>
<td>随时会被回收， 创建了可能很快就会被回收</td>
<td>可能被JVM团队内部用来跟踪JVM的垃圾回收活动</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">* its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">* ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">* == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">* entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">* as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么在这里Entry的key要使用弱引用呢？</p>
<p>不妨反过来想想，如果使用强引用，当ThreadLocal对象（假设为ThreadLocal@123456）的引用（是一个强引用，指向ThreadLocal@123456）被回收了，ThreadLocalMap本身（线程对象中）依然还持有ThreadLocal@123456的强引用，如果没有手动删除这个key，则ThreadLocal@123456不会被回收，所以只要当前线程不消亡，ThreadLocalMap引用的那些对象就不会被回收，可以认为这导致Entry内存泄漏。</p>
<p>那使用弱引用的好处呢？</p>
<p>如果使用弱引用，那指向ThreadLocal@123456对象的引用就两个：TL_INT强引用，和ThreadLocalMap中Entry的弱引用。一旦TL_INT被回收，则指向ThreadLocal@123456的就只有弱引用了，在下次gc的时候，这个ThreadLocal@123456就会被回收。</p>
<p>那么问题来了，ThreadLocal@123456对象只是作为ThreadLocalMap的一个key而存在的，现在它被回收了，但是它对应的value并没有被回收，内存泄露依然存在！而且key被删了之后，变成了null，value更是无法被访问到了！针对这一问题，ThreadLocalMap类的设计本身已经有了这一问题的解决方案，那就是在每次get()/set()/remove()ThreadLocalMap中的值的时候，会自动清理key为null的value。如此一来，value也能被回收了。</p>
<p>既然对key使用弱引用，能使key自动回收，那为什么不对value使用弱引用？答案显而易见，假设往ThreadLocalMap里存了一个value，gc过后value便消失了，那就无法使用ThreadLocalMap来达到存储全线程变量的效果了。（但是再次访问该key的时候，依然能取到value，此时取得的value是该value的初始值。即在删除之后，如果再次访问，取到null，会重新调用初始化方法。）</p>
<p>所以我们总结了使用ThreadLocal时会发生内存泄漏的前提条件：</p>
<ol>
<li><p>ThreadLocal引用被设置为null，且后面没有set，get，remove操作。</p>
</li>
<li><p>线程一直运行，不停止。（线程池）</p>
</li>
<li><p>触发了垃圾回收。（Minor GC或Full GC）</p>
</li>
</ol>
<p>我们看到ThreadLocal出现内存泄漏条件还是很苛刻的，所以我们只要破坏其中一个条件就可以避免内存泄漏，但为了更好的避免这种情况的发生我们使用ThreadLocal时遵守以下两个小原则:</p>
<ol>
<li>ThreadLocal申明为private static final。<br>  Private与final 尽可能不让他人修改变更引用，<br>  Static 表示为类属性，只有在程序结束才会被回收。</li>
<li>ThreadLocal使用后务必调用remove方法。<br>   最简单有效的方法是使用后将其移除。</li>
</ol>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Git技术文档 - 基本操作指南</title>
    <url>/2020/05/13/Git%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%20-%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="一、架构"><a href="#一、架构" class="headerlink" title="一、架构"></a>一、架构</h2><ul>
<li>工作区</li>
<li>暂存区</li>
<li>本地库（版本库）</li>
</ul>
<p>git add：工作区→暂存区</p>
<p>git commit：暂存区→本地库</p>
<h2 id="二、本地库和远程库"><a href="#二、本地库和远程库" class="headerlink" title="二、本地库和远程库"></a>二、本地库和远程库</h2><h3 id="本团队协作"><a href="#本团队协作" class="headerlink" title="本团队协作"></a>本团队协作</h3><p><img src="/2020/05/13/Git%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%20-%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/%E6%9C%AC%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C.png" alt="image-20200412221514694"></p>
<h3 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h3><p><img src="/2020/05/13/Git%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%20-%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/%E8%B7%A8%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C.png" alt="image-20200412222450940"></p>
<h2 id="三、操作"><a href="#三、操作" class="headerlink" title="三、操作"></a>三、操作</h2><h3 id="本地库初始化"><a href="#本地库初始化" class="headerlink" title="本地库初始化"></a>本地库初始化</h3><ul>
<li>git init</li>
</ul>
<p>会自动生成.git隐藏目录，不要修改。</p>
<h3 id="设置签名"><a href="#设置签名" class="headerlink" title="设置签名"></a>设置签名</h3><p>设置用户名与邮箱，此处和登陆GitHub的用户没有任何关系。</p>
<ul>
<li>git config –global user.name xxx </li>
<li>git config –global user.name <a href="mailto:xxxxxx@xx.com">xxxxxx@xx.com</a></li>
</ul>
<p>若不加global，则设置的参数只针对当前仓库。</p>
<h4 id="查看设置"><a href="#查看设置" class="headerlink" title="查看设置"></a>查看设置</h4><p>git config user.name/user.email</p>
<p>cat .git/config</p>
<h3 id="暂存、提交、删除"><a href="#暂存、提交、删除" class="headerlink" title="暂存、提交、删除"></a>暂存、提交、删除</h3><ul>
<li>git status 查看目前git仓库的状态</li>
<li>git add filename 将文件加入暂存区<ul>
<li>git add . 暂存所有修改</li>
<li>git add –all 同上</li>
</ul>
</li>
<li>git checkout – filename 用于未使用git add时，放弃对单个文件的修改<ul>
<li>git reset HEAD filename 也是相当于从暂存区清除文件</li>
</ul>
</li>
<li>git commit -m ‘xxxxxxx’ filename 提交文件<ul>
<li>git commit -a -m ‘xxxxxx’：执行此命令的话不用add，直接提交所有改动</li>
</ul>
</li>
</ul>
<h4 id="取消暂存文件"><a href="#取消暂存文件" class="headerlink" title="取消暂存文件"></a>取消暂存文件</h4><ul>
<li>git rm –cached filename 从暂存区移除文件/文件夹</li>
<li>git reset HEAD . 清空暂存区所有文件</li>
</ul>
<h4 id="取消对文件的版本追踪"><a href="#取消对文件的版本追踪" class="headerlink" title="取消对文件的版本追踪"></a>取消对文件的版本追踪</h4><p>每次用git status查看状态时总是列出未被跟踪的文件</p>
<p>解决方法：</p>
<ol>
<li><p>当被跟踪的文件里面有不想跟踪的文件时，使用命令git rm删除文件</p>
<ul>
<li>git rm –cached readme1.txt 删除readme1.txt的跟踪，并保留在本地。</li>
<li>git rm –f readme1.txt 删除readme1.txt的跟踪，并且删除本地文件。</li>
</ul>
</li>
<li><p>每次用git status查看状态时总是列出未被跟踪的文件，可以通过.gitignore文件达到目的。</p>
<p>编辑.gitignore文件，git会忽略文件中所列的文件和文件夹。如下。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;target</span><br><span class="line">&#x2F;.project</span><br><span class="line">&#x2F;.settings</span><br><span class="line">&#x2F;.classpath</span><br><span class="line">&#x2F;.idea</span><br><span class="line">&#x2F;.DS_Store</span><br><span class="line">*.iml</span><br><span class="line">&#x2F;src&#x2F;test&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;json&#x2F;bvt&#x2F;parser&#x2F;autoType&#x2F;</span><br><span class="line">&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>

<p>   如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。</p>
<p>   <strong>.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：</strong></p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m 'update .gitignore'</span><br></pre></td></tr></table></figure>

<h3 id="文件差异比较"><a href="#文件差异比较" class="headerlink" title="文件差异比较"></a>文件差异比较</h3><ul>
<li>git diff  [文件名]<ul>
<li>git diff test.txt  <code>将工作区中的文件和暂存区对应文件进行比较</code></li>
</ul>
</li>
<li>将工作区中的文件和本地库历史记录比较<ul>
<li>git diff HEAD test.txt  # 比较最新一次修改</li>
<li>git diff HEAD^ text.txt # 比较上一次修改</li>
<li>git diff 46e8eaa test.txt # 比较历史记录号为 46e8eaa的修改</li>
</ul>
</li>
</ul>
<h3 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h3><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><ul>
<li>git log 显示提交日志信息<ul>
<li>git log –pretty=online</li>
<li>git log –online</li>
</ul>
</li>
<li>git reflog 显示的日志有助于帮助前进和后退版本</li>
</ul>
<h4 id="前进-后退版本"><a href="#前进-后退版本" class="headerlink" title="前进/后退版本"></a>前进/后退版本</h4><p>移动HEAD指针</p>
<h5 id="基于索引值"><a href="#基于索引值" class="headerlink" title="基于索引值"></a>基于索引值</h5><p>git reset –hard 索引值的一部分（reflog中）</p>
<h5 id="使用-、-（只能后退）"><a href="#使用-、-（只能后退）" class="headerlink" title="使用^、~（只能后退）"></a>使用^、~（只能后退）</h5><ul>
<li>git reset –hard HEAD^ 回退一个版本</li>
<li>git reset –hard HEAD~3 回退三个版本</li>
</ul>
<h5 id="reset命令的三个参数"><a href="#reset命令的三个参数" class="headerlink" title="reset命令的三个参数"></a>reset命令的三个参数</h5><ul>
<li>–soft 仅仅在本地库移动指针</li>
<li>–mixed 在本地库移动指针，重置暂存区</li>
<li>–hard 在本地库移动指针，重置暂存区，重置工作区</li>
</ul>
<h5 id="删除文件找回"><a href="#删除文件找回" class="headerlink" title="删除文件找回"></a>删除文件找回</h5><p>前提：删除前，文件有提交</p>
<ul>
<li>git rm filename 使用git删除文件，并提交至暂存区</li>
<li>git reset –hard xxxx 回退到之前的记录</li>
</ul>
<h2 id="四、分支"><a href="#四、分支" class="headerlink" title="四、分支"></a>四、分支</h2><p>查看分支</p>
<ul>
<li>git branch -v</li>
</ul>
<p>创建wvfc</p>
<ul>
<li>git branch xxxx</li>
</ul>
<p>切换分支</p>
<ul>
<li>git checkout 分支名</li>
</ul>
<p>合并分支</p>
<ol>
<li>切换至将要被合并的分支上，例如master</li>
<li>git merge hot-fix 将指定分支合并到当前分支</li>
</ol>
<p>删除分支</p>
<ul>
<li>git branch -d 分支名</li>
</ul>
<h4 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h4><ul>
<li>merge过程中产生冲突，会在文件内容中产生一些特殊符号，需要将这部分信息选择后删除特殊符号</li>
<li>解决完后 git add</li>
<li>然后 git commit，不加任何参数，标志冲突解决完成</li>
</ul>
<h3 id="强制覆盖分支"><a href="#强制覆盖分支" class="headerlink" title="强制覆盖分支"></a>强制覆盖分支</h3><p>使用git进行合作时，有时会建立很多的分支，当分支两两合并完，想将代码移到主分支上时，如果采用merge的方式，往往会有很多冲突。比较推荐的一种方法是将分支内容强制覆盖到主分支（前提是主分支里的东西不再需要），效果类似于清空主分支并将其它分支复制粘贴过去。</p>
<ul>
<li><p>方法一：git push origin test:master -f </p>
</li>
<li><p>方法二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master                          &#x2F;&#x2F;将当前分支切换到主分支</span><br><span class="line"></span><br><span class="line">git reset --hard test                            &#x2F;&#x2F;将主分支重置为test分支</span><br><span class="line"></span><br><span class="line">git push origin master -f             &#x2F;&#x2F;将重置后的master分支强制推送到远程仓库</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="五、远程仓库"><a href="#五、远程仓库" class="headerlink" title="五、远程仓库"></a>五、远程仓库</h2><h3 id="SSH免密配置"><a href="#SSH免密配置" class="headerlink" title="SSH免密配置"></a>SSH免密配置</h3><blockquote>
<p>如果不使用SSH免密，在执行一次远程push后会发现不用再输入密码了。这是因为windows中的凭据管理器会记录登录凭据。但在其他系统下不是这样。设置SSH免密可省下每次推送都需要登录的麻烦。</p>
</blockquote>
<h4 id="设置步骤"><a href="#设置步骤" class="headerlink" title="设置步骤"></a>设置步骤</h4><ol>
<li><p>首先你需要确认一下自己是否已经拥有密钥了，默认情况下，用户的 SSH 密钥存储在其 <code>~/.ssh</code> 目录下。如果是Windows，则为C:\Users\用户名.ssh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/.ssh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">authorized_keys2  id_rsa       known_hosts</span><br><span class="line">config            id_rsa.pub</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有这些文件，则需要重新创建。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 邮箱可以随便填</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"xx@xx.com"</span></span></span><br></pre></td></tr></table></figure>
<p>默认会在上面所说的默认目录下生成<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件</p>
</li>
<li><p>将ssh key添加到GitHub中</p>
</li>
<li><p>在Git的bash客户端创建SSH地址的别名映射(不能使用Https地址的别名映射推送)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add ssh远程库别名 ssh远程库地址</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="管理远程仓库别名"><a href="#管理远程仓库别名" class="headerlink" title="管理远程仓库别名"></a>管理远程仓库别名</h3><ul>
<li><p>git remote -v    查看所有别名</p>
</li>
<li><p>git remote add 别名 地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add dust https://github.com/MaKunPeng/Dust.git</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><ul>
<li>git push origin master</li>
</ul>
<h4 id="强制推送"><a href="#强制推送" class="headerlink" title="强制推送"></a>强制推送</h4><p>无视冲突，完全合并。假设有一个分支test，要将这个分支的内容完全覆盖掉主分支master</p>
<p>git push origin test:master–force</p>
<h3 id="邀请成员加入团队"><a href="#邀请成员加入团队" class="headerlink" title="邀请成员加入团队"></a>邀请成员加入团队</h3><p><img src="/2020/05/13/Git%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%20-%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/%E9%82%80%E8%AF%B7%E6%88%90%E5%91%98%E5%8A%A0%E5%85%A5%E5%9B%A2%E9%98%9F.png" alt="image-20200413020055090"></p>
<p>然后复制邀请地址，发送给被邀请人，被邀请人打开链接，点击接收，完成。</p>
<h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p>pull = fetch + merge</p>
<ul>
<li>git fetch origin master</li>
</ul>
<p>fetch只是将远程仓库中的文件下载至本地，但并没有改本地<code>工作区</code>中的文件，如果想要查看从远程仓库下载下来的文件，可执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout orgin&#x2F;master #切换到远程仓库的分支，这时就可以查看了</span><br></pre></td></tr></table></figure>

<p>然后再进行merge</p>
<ul>
<li>git merge origin/master</li>
</ul>
<p>当然也可以直接使用pull</p>
<ul>
<li>git pull  origin master</li>
</ul>
<h3 id="跨团队操作"><a href="#跨团队操作" class="headerlink" title="跨团队操作"></a>跨团队操作</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p>其他团队成员先在github上fork项目</p>
<h4 id="发起pull-requests"><a href="#发起pull-requests" class="headerlink" title="发起pull requests"></a>发起pull requests</h4><p>在github上点击pull requests</p>
<p><img src="/2020/05/13/Git%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%20-%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/%E5%8F%91%E8%B5%B7pullrequest.png" alt="image-20200413021931045"></p>
<h4 id="审核pull-requests"><a href="#审核pull-requests" class="headerlink" title="审核pull requests"></a>审核pull requests</h4><p>同样点击pull requests</p>
<p>可以点击files changed查看修改，然后merge</p>
<h3 id="Win10凭据管理"><a href="#Win10凭据管理" class="headerlink" title="Win10凭据管理"></a>Win10凭据管理</h3><p>如果不用ssh免密登陆的话，git是不会记住https方式的用户名和密码的。</p>
<p>Win10自带的凭据管理器会记住，所以第二次操作时就不用输入了。</p>
<h2 id="六、问题解决"><a href="#六、问题解决" class="headerlink" title="六、问题解决"></a>六、问题解决</h2><h3 id="SSH免密"><a href="#SSH免密" class="headerlink" title="SSH免密"></a>SSH免密</h3><p>ssh免密生成密钥用的邮箱一定是github登录邮箱，同时，git config –gobal user.email中设置也必须是同一个邮箱。</p>
<h3 id="push报错"><a href="#push报错" class="headerlink" title="push报错"></a>push报错</h3><p><a href="https://blog.csdn.net/u012145252/article/details/80628451" target="_blank" rel="noopener">https://blog.csdn.net/u012145252/article/details/80628451</a></p>
<p><code>fatal: refusing to merge unrelated histories</code></p>
<p>出现这个问题的最主要原因还是在于本地仓库和远程仓库实际上是独立的两个仓库。假如我之前是直接clone的方式在本地建立起远程github仓库的克隆本地仓库就不会有这问题了。</p>
<p>可以在pull命令后紧接着使用<em>–allow-unrelated-histories</em>选项来解决问题（该选项可以合并两个独立启动仓库的历史）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security - 认证授权的基本概念</title>
    <url>/2018/02/01/Spring%20Security%20-%20%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="一、认证"><a href="#一、认证" class="headerlink" title="一、认证"></a>一、认证</h2><p><strong>认证就是判断一个用户身份是否合法的过程。</strong></p>
<p>认证是为了保护系统的隐私数据与资源，用户身份合法是访问资源的前提。例如，登陆QQ时，需要输入用户名和密码，这就是一个认证的过程。只有用户名、密码校验通过后，用户才能继续操作。</p>
<p>常见的认证方式有：用户名密码登录、二维码登录、短信登录、指纹认证等等。</p>
<h2 id="二、会话"><a href="#二、会话" class="headerlink" title="二、会话"></a>二、会话</h2><blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/计算机科学" target="_blank" rel="noopener">计算机科学</a>领域来说，尤其是在<a href="https://zh.wikipedia.org/wiki/计算机网络" target="_blank" rel="noopener">网络</a>领域，<strong>会话</strong>（<strong>session</strong>，Microsoft Windows 中文版译作<strong>工作阶段</strong>）是一种持久网络协议，在用户（或用户代理）端和服务器端之间创建关联，从而起到交换数据包的作用机制，session在<a href="https://zh.wikipedia.org/wiki/网络协议" target="_blank" rel="noopener">网络协议</a>（例如<a href="https://zh.wikipedia.org/wiki/Telnet" target="_blank" rel="noopener">telnet</a>或<a href="https://zh.wikipedia.org/wiki/FTP" target="_blank" rel="noopener">FTP</a>）中是非常重要的部分。</p>
<p>在不包含<a href="https://zh.wikipedia.org/wiki/会话层" target="_blank" rel="noopener">会话层</a>（例如<a href="https://zh.wikipedia.org/wiki/UDP" target="_blank" rel="noopener">UDP</a>）或者是无法长时间驻留<a href="https://zh.wikipedia.org/wiki/会话层" target="_blank" rel="noopener">会话层</a>（例如<a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP</a>）的传输协议中，会话的维持需要依靠在传输数据中的高级别程序。例如，在浏览器和远程主机之间的HTTP传输中，HTTP cookie就会被用来包含一些相关的信息，例如session ID，参数和权限信息等。</p>
<p>—- 来自维基百科</p>
</blockquote>
<p>在认证授权系统中，为了避免用户每一次操作都需要进行繁琐的认证，大都选择将用户的认证信息保存在会话中，使用会话来记录并保持当前用户的登录状态。这样用户只需在第一次登陆时进行认证，后续操作会自动从会话中取出用户认证信息，极大方便了用户的操作。</p>
<p>认证系统中，会话常见的实现方式有基于session的方式，基于token的方式等等。</p>
<h3 id="2-1-基于Session的认证"><a href="#2-1-基于Session的认证" class="headerlink" title="2.1 基于Session的认证"></a>2.1 基于Session的认证</h3><p>Session是一种服务器端的会话机制，被广泛应用于Web应用中。由于HTTP是一种无状态协议，所以当需要记录用户状态时，就需要用某种机制来识具体的用户，这个机制可以用Session实现。典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。这个数据可以保存在集群、数据库、文件中。</p>
<p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>
<p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
<h3 id="2-2-基于Token的认证"><a href="#2-2-基于Token的认证" class="headerlink" title="2.2 基于Token的认证"></a>2.2 基于Token的认证</h3><p>Token是用户登录成功后，服务端生成的一段包含了特殊信息的数字令牌。与Session相同，Token也会被返回到客户端，但客户端保存Token的方式更灵活，可以保存到Cookie中也可以存到Local Storage中。这样用户后续的访问会携带这个Token，服务器通过验证这个Token来判断用户的登录状态。</p>
<h3 id="2-3-两种方式的区别"><a href="#2-3-两种方式的区别" class="headerlink" title="2.3 两种方式的区别"></a>2.3 两种方式的区别</h3><p>除了上面提到的客户端保存认证信息的方式不同外，两种方式在服务器端的实现也是有很大差别的。</p>
<ul>
<li>基于Session的认证方式由Servlet规范制定，服务端需要存储Session信息，这会占用一定资源，而且在分布式场景下会带来一些问题，这个我们后续会提到。</li>
<li>基于Token的认证方式不需要服务端存储Token，并且不限制客户端的存储方式。万物互联的今天，越来越多类型的客户端需要接入系统，系统多是采用前后分离的方式实现，故使用Token更为合适。</li>
</ul>
<h2 id="三、授权"><a href="#三、授权" class="headerlink" title="三、授权"></a>三、授权</h2><h3 id="3-1-什么是授权"><a href="#3-1-什么是授权" class="headerlink" title="3.1 什么是授权"></a>3.1 什么是授权</h3><p>一个应用是由多个功能模块和无数的资源组成的，而这些功能和资源往往不会全部对用户开放，多是有条件、有选择的对用户开放。比如，百度网盘的很多功能是需要开通会员后才能使用的，这些功能就是由用户权限控制的。</p>
<p>授权位于认证之后，是为了更细粒度的控制用户对资源的访问。系统会根据用户的权限来控制用户对不同资源的访问。</p>
<h3 id="3-2-授权的数据模型"><a href="#3-2-授权的数据模型" class="headerlink" title="3.2 授权的数据模型"></a>3.2 授权的数据模型</h3><ul>
<li>Who，主体（Subject），一般指用户</li>
<li>What，资源（Resource），分为功能资源（系统菜单）和数据资源（商品信息）</li>
<li>How，权限（Permission），用户操作权限</li>
</ul>
<p>相关的数据模型（数据库表）如下：</p>
<p>主体（用户ID，帐号，密码，……）</p>
<p>资源（资源ID，资源名称，访问路径，……）</p>
<p>权限（权限ID，权限标识，权限名称，资源ID，……）</p>
<p>角色（角色ID，角色名称，……）</p>
<p>角色和权限关系表（角色ID，权限ID，……）</p>
<p>主体和角色关系表（用户ID，角色ID，……)</p>
<p><img src="/2018/02/01/Spring%20Security%20-%20%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E6%9D%83%E9%99%90%E8%A1%A8.png" alt></p>
<p>通常生产实践中会将资源和权限表合并为一张表，这样一共五张表。</p>
<h2 id="四、RBAC"><a href="#四、RBAC" class="headerlink" title="四、RBAC"></a>四、RBAC</h2><h3 id="4-1-基于角色的访问控制（Role-Based-Access-Control）"><a href="#4-1-基于角色的访问控制（Role-Based-Access-Control）" class="headerlink" title="4.1 基于角色的访问控制（Role-Based Access Control）"></a>4.1 基于角色的访问控制（Role-Based Access Control）</h3><p>判断逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.hasRole(<span class="string">"经理"</span>)) &#123;</span><br><span class="line">	查询人员();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上图查询人员功能所需的角色发生了变化，则需要修改判断逻辑代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.hasRole(<span class="string">"经理"</span>) || user.hasRole(<span class="string">"HR"</span>)) &#123;</span><br><span class="line">    查询人员();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦变化，需要修改源代码，扩展性较差。</p>
<h3 id="4-2-基于资源的访问控制（Resource-Based-Access-Control）"><a href="#4-2-基于资源的访问控制（Resource-Based-Access-Control）" class="headerlink" title="4.2 基于资源的访问控制（Resource-Based Access Control）"></a>4.2 基于资源的访问控制（Resource-Based Access Control）</h3><p>判断逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.hasPermission(<span class="string">"查询人员权限"</span>)) &#123;</span><br><span class="line">    查询人员();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：系统设计时定义好功能资源的权限标识，即使角色发生变化，也不会表现在代码上。可扩展性强。</p>
]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
        <tag>访问控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Java阻塞队列 - DelayQueue（延迟队列）</title>
    <url>/2018/05/13/DelayQueue%EF%BC%88%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>一种由延迟元素组成的无边界阻塞队列，其中一个元素只有在其延迟过期时才能被接受。队列的头是最快过期的延迟元素。如果没有延迟过期，则没有head，poll将返回null。当元素的getDelay（TimeUnit.NANOSECONDS）方法返回的值小于或等于零时，将发生过期。即使使用take或poll不能删除未过期的元素，也可以将它们视为正常元素。例如，size方法返回过期和未过期元素的计数。此队列不允许空元素（null）。</p>
<p>这个类及其迭代器实现了集合和迭代器接口的所有可选方法。方法Iterator()中提供的迭代器不能保证以任何特定顺序遍历DelayQueue的元素。</p>
<p>这个类是Java集合框架的成员。</p>
<p>—- Doug Lea</p>
</blockquote>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在我们的业务中通常会有一些需求是这样的： </p>
<ol>
<li>淘宝订单业务:<code>下单之后如果三十分钟之内没有付款就自动取消订单</code>。</li>
<li>饿了吗订餐通知:<code>下单成功后60s之后给用户发送短信通知</code>。</li>
<li>缓存系统的设计，缓存中的对象，超过了空闲时间，需要从缓存中移出。</li>
<li>……</li>
</ol>
<p>这类业务我们可以总结出一个特点:需要延迟工作。 </p>
<p>DelayQueue可以满足这类需求。</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>首先，DelayQueue规则定了队列中的元素必须实现Delayed接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Thread leader = <span class="keyword">null</span>; <span class="comment">// 等待队头元素的线程</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由源码可以看出DelayQueue内部使用了优先级队列PriorityQueue来保存元素。当调用DelayQueue的offer方法时，把Delayed对象加入到优先队列q中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        q.offer(e);</span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123; <span class="comment">// 如果新加入的元素是最快过期的元素</span></span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal(); <span class="comment">//唤醒阻塞的消费者线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DelayQueue的take方法，把优先队列q的first拿出来（peek），如果没有达到延时阀值，则进行await处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 调用后一直阻塞直到获得锁,但是接受中断信号</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// for(;;)比while(true)生成的字节码指令更少，不占用寄存器，而且没有判断跳转</span></span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await(); <span class="comment">// 如果没有元素，直接阻塞</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS); <span class="comment">// 判断是否过期</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) <span class="comment">// 如果过期了，直接弹出队头</span></span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await(); <span class="comment">// 如果没过期，且已经有leader在等待队头元素，则继续阻塞等待,同时释放锁</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        available.awaitNanos(delay); <span class="comment">// 如果leader就是当前线程，则阻塞指定的延迟时间</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DelayQueue的线程安全性是由ReentrantLock保证的。线程进入方法后会先获取锁，如果获取不到，会阻塞直至获取，如果获取到了，就会继续操作，此时如果获取的元素未过期，则本线程阻塞，一旦阻塞就会释放当前线程持有的锁。</p>
<p>当一个线程成为leader时，它只等待下一个延迟过去，而其他线程则无限期地等待。leader线程必须在从 take() 或 poll(…) 返回之前向其他线程发出信号，除非其他线程在此期间成为引导线程。</p>
<h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><p>下面以一个简单的生产者-消费者的例子来展示DelayQueue的延时处理。我们将向一个延时队列中扔进一堆延迟时间不等的任务，然后单独开启一个线程从队列中消费数据。</p>
<p>任务对象必须实现Delayed接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> delayTime; <span class="comment">// 多久之后执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTime; <span class="comment">// 过期时间点</span></span><br><span class="line">    <span class="keyword">private</span> String taskName; <span class="comment">// 任务名称</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String taskName, <span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskName = taskName;</span><br><span class="line">        <span class="keyword">this</span>.delayTime = delayTime;</span><br><span class="line">        <span class="keyword">this</span>.expireTime = System.nanoTime() + TimeUnit.NANOSECONDS.convert(delayTime, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写比较方法，让队列中的元素按照过期时间来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> d = (<span class="keyword">this</span>.getDelay(TimeUnit.NANOSECONDS) - o.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">        <span class="keyword">return</span> d &gt; <span class="number">0</span> ? <span class="number">1</span> : d &lt; <span class="number">0</span> ? -<span class="number">1</span> :<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// return (int) d; 这里绝对不能使用强制转换，极易出现上限溢出后发生数据截断。导致最后排序结果不符合预期。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(<span class="keyword">this</span>.expireTime - System.nanoTime(), TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Task:"</span> + taskName + <span class="string">" [delayTime="</span> + delayTime + <span class="string">", expireTime="</span> + expireTime + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> DelayQueue&lt;Task&gt; taskQueue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">    Thread producer = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                taskQueue.put(<span class="keyword">new</span> Task(i + <span class="string">""</span>, i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    producer.start();</span><br><span class="line">    </span><br><span class="line">    Thread consumer = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="comment">// 消费队列中的过期元素，执行doAction</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Task task;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task = taskQueue.take();</span><br><span class="line">                    task.doAction();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    consumer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下，各个任务依次打印：</p>
<p><img src="/2018/05/13/DelayQueue%EF%BC%88%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%EF%BC%89/image-20200513171457561.png" alt="image-20200513171457561"></p>
<p>这里还有一个实现缓存的例子，链接如下：<br> <a href="https://link.jianshu.com?t=http://www.cnblogs.com/jobs/archive/2007/04/27/730255.html" target="_blank" rel="noopener">http://www.cnblogs.com/jobs/archive/2007/04/27/730255.html</a></p>
<h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><p>在实现Delayed接口时，重写compareTo()方法是很重要的，只有compareTo()方法没有问题，才能保证队列中元素是按过期时间排序的。如果不重写，则需要传入比较器。</p>
<p>DelayQueue中的元素可以通过remove方法移除，此时请保证equals与hashCode方法的正确性。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>阻塞队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库 - 事务隔离与数据库锁</title>
    <url>/2019/12/01/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/</url>
    <content><![CDATA[<h2 id="一、什么是事务？"><a href="#一、什么是事务？" class="headerlink" title="一、什么是事务？"></a>一、什么是事务？</h2><blockquote>
<p><strong>数据库事务</strong>（<strong>Transaction</strong>）是<a href="https://zh.wikipedia.org/wiki/数据库管理系统" target="_blank" rel="noopener">数据库管理系统</a>执行过程中的一个逻辑单位，由一个有限的<a href="https://zh.wikipedia.org/wiki/数据库" target="_blank" rel="noopener">数据库</a>操作序列构成。这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p>
<p>—- <em>来自wikipedia</em></p>
</blockquote>
<p>例子：某人要在商店使用<a href="https://zh.wikipedia.org/wiki/電子貨幣" target="_blank" rel="noopener">电子货币</a>购买100元的东西，当中至少包括两个操作：</p>
<ol>
<li>该人账户减少100元</li>
<li>商店账户增加100元</li>
</ol>
<p><strong>支持事务的数据库管理系统</strong>（<strong>transactional DBMS</strong>）就是要确保以上两个操作（整个“事务”）都能完成，或一起取消；否则就会出现100元平白消失或出现的情况。</p>
<p>在 MySQL 中，事务支持是在引擎层实现的。MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。</p>
<h3 id="事务的特性（ACID）"><a href="#事务的特性（ACID）" class="headerlink" title="事务的特性（ACID）"></a>事务的特性（ACID）</h3><ul>
<li><strong>原子性</strong><br>　　事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。 </li>
<li><strong>一致性</strong><br>　　 事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">数据结构</a>（如 B 树索引或双向链表）都必须是正确的。某些维护一致性的责任由应用程序开发人员承担，他们必须确保应用程序已强制所有已知的完整性约束。例如，当开发用于转帐的应用程序时，应避免在转帐过程中任意移动小数点。 </li>
<li><strong>隔离性</strong><br>　　由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。当事务可序列化时将获得最高的隔离级别。在此级别上，从一组可并行执行的事务获得的结果与通过连续运行每个事务所获得的结果相同。由于高度隔离会限制可并行执行的事务数，所以一些应用程序降低隔离级别以换取更大的吞吐量。  </li>
<li><strong>持久性</strong><br>　　 事务完成之后，它对于系统的影响是永久性的。</li>
</ul>
<h2 id="二、隔离性与隔离级别"><a href="#二、隔离性与隔离级别" class="headerlink" title="二、隔离性与隔离级别"></a>二、隔离性与隔离级别</h2><h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p>
<p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。</p>
<ul>
<li><strong>Read Uncommitted（读取未提交）</strong><br>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</li>
<li><strong>Read Committed（读取已提交）</strong><br>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</li>
<li><strong>Repeatable Read（可重读）</strong><br>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</li>
<li><strong>Serializable（可串行化）</strong><br>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</li>
</ul>
<p>由不同的隔离级别导致的问题如下：</p>
<ul>
<li><p><strong>脏读(Drity Read)</strong>：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>
</li>
<li><p><strong>不可重复读(Non-repeatable read)</strong>：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p>
</li>
<li><p><strong>幻读(Phantom Read)</strong>：在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
</li>
</ul>
<p>对应关系如图：</p>
<img src="http://dl.iteye.com/upload/picture/pic/72610/af5b9c1e-4517-3df2-ad62-af25d1672d12.jpg" alt="img" style="zoom:67%;">

<h3 id="事务隔离的实现（MySQL为例）"><a href="#事务隔离的实现（MySQL为例）" class="headerlink" title="事务隔离的实现（MySQL为例）"></a>事务隔离的实现（MySQL为例）</h3><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。我们可以看到在不同的隔离级别下，数据库行为是有所不同的。</p>
<p><strong>Oracle 数据库的默认隔离级别是“读提交”，而MySQL数据库的默认隔离级别是“可重复读”。</strong>因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”。</p>
<p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录：</p>
<img src="https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png" alt="img" style="zoom:50%;">

<p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。</p>
<p>同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？</p>
<p>答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。</p>
<p><strong>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</strong></p>
<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>
<p>在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p>
<h2 id="三、数据库锁"><a href="#三、数据库锁" class="headerlink" title="三、数据库锁"></a>三、数据库锁</h2><blockquote>
<p>数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p>
</blockquote>
<p>数据库中锁的种类有很多，根据不同的划分标准，可以分为不同的种类，也因此衍生出了各种关于锁的专业名词，如果没捋清这其中的关系，很容易陷入术语的漩涡，最后弄得一头雾水。</p>
<p>所以我在这里先摆张从网上找的关系图，先让大家对锁有个整体上的认识，不至于犯嘀咕。</p>
<img src="http://raw.githubusercontent.com/IMWYY/AboutMyself/master/picBed/Screenshot1520500121.png" alt="img" style="zoom:100%;">

<h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><p><strong>悲观锁</strong></p>
<p>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
<ol>
<li><p>使用悲观锁，我们必须关闭mysql数据库的自动提交属性，采用手动提交事务的方式，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。</p>
</li>
<li><p>需要注意的是，在事务中，只有SELECT … FOR UPDATE 或LOCK IN SHARE MODE 同一笔数据时会等待其它事务结束后才执行，一般SELECT … 则不受此影响。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)。</p>
</li>
<li><p>补充：MySQL中select…for update的Row Lock与Table Lock</p>
<p>使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认Row-Level Lock，所以只有明确地指定主键（或有索引的地方），MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。</p>
</li>
</ol>
<p><strong>乐观锁</strong></p>
<p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做（<strong>一般是回滚事务</strong>）。那么我们如何实现乐观锁呢，一般来说有以下2种方式：</p>
<ol>
<li>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</li>
<li>乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</li>
</ol>
<p><strong>总结：</strong></p>
<p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p>
<p>另外，高并发情况下个人认为乐观锁要好于悲观锁，因为悲观锁的机制使得各个线程等待时间过长，极其影响效率，乐观锁可以在一定程度上提高并发度。</p>
<h3 id="共享锁与排他锁"><a href="#共享锁与排他锁" class="headerlink" title="共享锁与排他锁"></a>共享锁与排他锁</h3><p>共享锁（又称<strong>读锁</strong>）、排它锁（又称<strong>写锁</strong>）。</p>
<p><strong>共享锁（S）</strong></p>
<ul>
<li><p>加锁与解锁：当一个事务执行select语句时，数据库系统会为这个事务分配一把共享锁，来锁定被查询的数据。在默认情况下，数据被读取后，数据库系统立即解除共享锁。例如，当一个事务执行查询“SELECT * FROM accounts”语句时，数据库系统首先锁定第一行，读取之后，解除对第一行的锁定，然后锁定第二行。这样，在一个事务读操作过程中，允许其他事务同时更新accounts表中未锁定的行。</p>
</li>
<li><p>兼容性：如果数据资源上放置了共享锁，还能再放置共享锁和更新锁。</p>
</li>
<li><p>并发性能：具有良好的并发性能，当数据被放置共享锁后，还可以再放置共享锁或更新锁。所以并发性能很好。</p>
</li>
</ul>
<p><strong>排他锁（X）</strong></p>
<ul>
<li><p>加锁与解锁：当一个事务执行insert、update、select … for update或delete语句时，数据库系统会自动对SQL语句操纵的数据资源使用独占锁。如果该数据资源已经有其他锁（任何锁）存在时，就无法对其再放置独占锁了。</p>
</li>
<li><p>兼容性：独占锁不能和其他锁兼容，如果数据资源上已经加了独占锁，就不能再放置其他的锁了。同样，如果数据资源上已经放置了其他锁，那么也就不能再放置独占锁了。</p>
</li>
<li><p>并发性能：最差。只允许一个事务访问锁定的数据，如果其他事务也需要访问该数据，就必须等待。</p>
</li>
</ul>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>知乎上有个解释十分形象，如下：</p>
<ol>
<li><p>在MySQL中有表锁，读锁锁表，会阻塞其他事务修改表数据。写锁锁表，会阻塞其他事务读和写。</p>
</li>
<li><p>InnoDB引擎又支持行锁，行锁分为共享锁，一个事务对一行的共享只读锁。排它锁，一个事务对一行的排他读写锁。</p>
</li>
<li><p>这两种类型的锁共存的问题。考虑这个例子：事务A锁住了表中的一行，让这一行只能读，不能写。之后，事务B申请整个表的写锁。如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。</p>
</li>
</ol>
<p>数据库要怎么判断这个冲突呢？</p>
<ul>
<li>step1：判断表是否已被其他事务用表锁锁表</li>
<li>step2：判断表中的每一行是否已被行锁锁住。</li>
</ul>
<p>注意step2，这样的判断方法效率实在不高，因为需要遍历整个表。于是就有了意向锁。在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。</p>
<p>在意向锁存在的情况下，上面的判断可以改成</p>
<ul>
<li>step1：不变</li>
<li>step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。</li>
</ul>
<p>注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。</p>
<h3 id="怎么减少行锁对性能的影响？"><a href="#怎么减少行锁对性能的影响？" class="headerlink" title="怎么减少行锁对性能的影响？"></a>怎么减少行锁对性能的影响？</h3><p>先给你举个例子。在下面的操作序列中，事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键。</p>
<img src="https://static001.geekbang.org/resource/image/51/10/51f501f718e420244b0a2ec2ce858710.jpg" alt="img" style="zoom:50%;">

<p>这个问题的结论取决于事务 A 在执行完两条 update 语句后，持有哪些锁，以及在什么时候释放。你可以验证一下：实际上事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。</p>
<p>知道了这个答案，你一定知道了事务 A 持有的两个记录的行锁，都是在 <strong>commit 的时候才释放的</strong>。</p>
<p>也就是说，<strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议</strong>。</p>
<p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，<strong>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</strong>。</p>
<h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。</p>
<img src="https://static001.geekbang.org/resource/image/4d/52/4d0eeec7b136371b79248a0aed005a52.jpg" alt="img" style="zoom:50%;">

<p>这时候，事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</li>
</ul>
<p>在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p>
<p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p>所以，正常情况下我们还是要采用第二种策略，即：<strong>主动死锁检测</strong>，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p>
<p>你可以想象一下这个过程：</p>
<p>每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。那如果是我们上面说到的所有事务都要更新同一行的场景呢？每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。</p>
<p>假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。根据上面的分析，我们来讨论一下，怎么解决由这种热点行更新导致的性能问题呢？问题的症结在于，死锁检测要耗费大量的 CPU 资源。</p>
<p><strong>解决方案</strong></p>
<ul>
<li><p>一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</p>
</li>
<li><p>另一个思路是控制并发度。根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有 10 个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有 600 个客户端，这样即使每个客户端控制到只有 5 个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到 3000。</p>
<p>因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。</p>
</li>
<li><p>可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成 0 的时候，代码要有特殊处理。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Nginx的安装</title>
    <url>/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>环境：阿里云ECS Centos7</p>
</blockquote>
<h2 id="1-下载源码包"><a href="#1-下载源码包" class="headerlink" title="1. 下载源码包"></a>1. 下载源码包</h2><p>路径一般选择/usr下</p>
<blockquote>
<p>wget -c <a href="https://nginx.org/download/nginx-1.16.1.tar.gz" target="_blank" rel="noopener">https://nginx.org/download/nginx-1.16.1.tar.gz</a></p>
</blockquote>
<h2 id="2-安装所需依赖"><a href="#2-安装所需依赖" class="headerlink" title="2. 安装所需依赖"></a>2. 安装所需依赖</h2><blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y gcc-c++ #编译器</span><br><span class="line">yum install -y pcre pcre-devel #正则表达式</span><br><span class="line">yum install -y zlib zlib-devel #压缩算法</span><br><span class="line">yum install -y openssl openssl-devel #如果使用HTTPS，需要安装OpenSSL</span><br></pre></td></tr></table></figure>
</blockquote>
<p>devel 包主要是供开发用，至少包括以下2个东西:</p>
<ol>
<li>头文件</li>
<li>链接库<br>有的还含有开发文档或演示代码。</li>
</ol>
<p>以 glib 和 glib-devel 为例:</p>
<p>如果你安装基于 glib 开发的程序，只需要安装 glib 包就行了。</p>
<p>但是如果你要编译使用了 glib 的源代码，则需要安装 glib-devel。</p>
<h2 id="3-编译安装"><a href="#3-编译安装" class="headerlink" title="3. 编译安装"></a>3. 编译安装</h2><p>命令讲解</p>
<p>来自于GNU的AUTOCONF和AUTOMAKE工具。</p>
<ol>
<li><p>./configure 是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。</p>
<blockquote>
<p>这一步一般用来生成  Makefile，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，比如代码:./configure  –prefix=/usr 意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin （而不是默认的  /usr/local/bin),资源文件就会安装在  /usr/share（而不是默认的/usr/local/share）。同时一些软件的配置文件你可以通过指定 –sys-config=  参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许  ./configure –help 察看详细的说明帮助。</p>
</blockquote>
</li>
</ol>
<p>　2. make 是用来编译的，它从Makefile中读取指令，然后编译。</p>
<p>　3. make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。</p>
<p>解压</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure>
</blockquote>
<p>执行configure脚本，生成Makefile文件。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure>
</blockquote>
<p>编译</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="4-运行"><a href="#4-运行" class="headerlink" title="4. 运行"></a>4. 运行</h2><p>进入默认安装目录/usr/local，会发现已经创建了一个名为nginx的文件夹。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx #运行</span><br><span class="line">./nginx -s quit 或 ./nginx -s stop #关闭nginx</span><br><span class="line">./nginx -s reload #重启</span><br></pre></td></tr></table></figure>
</blockquote>
<p>查看nginx进程</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux | grep nginx</span><br></pre></td></tr></table></figure>
</blockquote>
<p>设置开机启动</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/rc.local</span><br><span class="line"><span class="meta">#</span><span class="bash">在文件底部增加启动代码即可</span></span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="5-问题解决"><a href="#5-问题解决" class="headerlink" title="5. 问题解决"></a>5. 问题解决</h2><h3 id="问题场景1"><a href="#问题场景1" class="headerlink" title="问题场景1"></a>问题场景1</h3><p>服务器重启后，重启nginx时报错nginx: [error] open()  “/usr/local/nginx/logs/nginx.pid” failed (2: No such file or  directory)，进入到logs目录发现确实没有nginx.pid文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;</span><br><span class="line">.&#x2F;nginx -s reload</span><br><span class="line">ngx_http_fastdfs_set pid&#x3D;1412</span><br><span class="line">ngx_http_fastdfs_set pid&#x3D;1412</span><br><span class="line">ngx_http_fastdfs_set pid&#x3D;1412</span><br><span class="line">ngx_http_fastdfs_set pid&#x3D;1412</span><br><span class="line">nginx: [error] open() &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&quot; failed (2: No such file or directory)</span><br></pre></td></tr></table></figure>

<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>使用指定nginx.conf文件的方式重启nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p>还有一种可能就是nginx.conf的nginx.pid被注释了,将下图中pid前的#去掉,保存退出再次启动nginx。</p>
<p>此时去logs目录下查看发现nginx.pid文件已经生成了。</p>
<h3 id="问题场景2"><a href="#问题场景2" class="headerlink" title="问题场景2"></a>问题场景2</h3><p>ngnix配置完成后外网无法访问</p>
<h4 id="第一种可能"><a href="#第一种可能" class="headerlink" title="第一种可能"></a>第一种可能</h4><p>阿里云服务器安全组配置中未配置80端口的访问规则。配置完即可。</p>
<h4 id="第二种可能"><a href="#第二种可能" class="headerlink" title="第二种可能"></a>第二种可能</h4><p>如果配置完阿里云服务器安全组策略后依然不可以，则考虑是Linux防火墙的问题。</p>
<p>所以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ]# &#x2F;sbin&#x2F;iptables -I INPUT -p tcp --dport 80 -j ACCEPT  </span><br><span class="line">[root@localhost ]# &#x2F;etc&#x2F;init.d&#x2F;iptables save  </span><br><span class="line">[root@localhost ]# &#x2F;etc&#x2F;init.d&#x2F;iptables restart</span><br></pre></td></tr></table></figure>

<p> 查找防火墙的文件命令：</p>
<p>vim /etc/sysconfig/iptables</p>
<p>打开文件之后会有：-A INPUT -p -tcp -m –dport 80 -j ACCEPT 此为打开了80端口</p>
<p>修改之后重启：service iptables restart</p>
<blockquote>
<p>Centos7中进行上述操作会报错，错误及解决方案如下</p>
</blockquote>
<p>报错：</p>
<p>Redirecting to /bin/systemctl restart iptables.service<br>Failed to restart iptables.service: Unit not found.</p>
<p>原因是因为CentOS7 里面是用 firewalld (相关介绍介绍请点击)来管理防火墙的。</p>
<ol>
<li><p>执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示FirewallD is not running，如下图所示。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/7dd98d1001e939013391d96372ec54e737d196df.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
<li><p>通过systemctl status firewalld查看firewalld状态，发现当前是dead状态，即防火墙未开启。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/55e736d12f2eb93882fe2eafdc628535e4dd6fdf.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
<li><p>通过systemctl start firewalld开启防火墙，没有任何提示即开启成功。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/e61190ef76c6a7efec9afc7bf4faaf51f3de662a.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
<li><p>再次通过systemctl status firewalld查看firewalld状态，显示running即已开启了。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/503d269759ee3d6d9f44d3964a166d224e4adee9.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
<li><p>如果要关闭防火墙设置，可能通过systemctl stop firewalld这条指令来关闭该功能。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/2e2eb9389b504fc2cecce458ecdde71191ef6ddf.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
<li><p>再次执行执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示success，表示设置成功，这样就可以继续后面的设置了。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/42166d224f4a20a4969c689a99529822730ed0e9.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
</ol>
<p>添加80端口为允许：</p>
<p>firewall-cmd –zone=public –add-port=80/tcp –permanent （–permanent 没有此参数重启后失效）</p>
]]></content>
      <categories>
        <category>Ngnix</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>从Top K算法问题入手，彻底掌握堆(Heap)结构</title>
    <url>/2020/07/29/%E4%BB%8ETop-K%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%E5%85%A5%E6%89%8B%EF%BC%8C%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1%E5%A0%86-Heap-%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>Top K问题是大数据和算法面试中最常遇到的问题之一。这个问题能很好的考验程序员对数据结构的理解，最近重修算法，借此机会，对这个问题作一个总结，除了解决Top K问题，我还将深入解读Top K算法背后的最大功臣 — 堆（Heap），并通过分析堆排序算法的性能来介绍计算机领域中一个重要概念 - 局部性原理。</p>
</blockquote>
<h2 id="什么是Top-K问题？"><a href="#什么是Top-K问题？" class="headerlink" title="什么是Top K问题？"></a>什么是Top K问题？</h2><p>一般来讲，Top K问题常以如下形式出现的：</p>
<ul>
<li>统计本月下载量前十的应用</li>
<li>统计本周用户搜索最多的前二十个关键词</li>
<li>统计一个小时内点击量前十的小说</li>
</ul>
<p>用户也好，关键词也好，将上述问题用编程语言抽象为一个统一的描述就是：<strong>给定一份未排序的数据，返回其中前K大元素。</strong></p>
<h3 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h3><p>我们可以将未排序的数据简化为一个无序数组。那么一个常见的做法就是我们先对这个数组进行排序，然后返回第K大元素。如果使用<strong>快速排序</strong>，这样的解法平均时间复杂度需要 <code>O(N*logN)</code>。乍一看好像还不错，但是仔细分析就能发现这其中的问题。<strong>快速排序</strong>在这个场景下的弊端在于：我们只想要排名前十的数据，但快排每次都会把所有数据全都处理一遍，即使你不需要前十之后的排名。也就是说，这个解决方案浪费了一部分不必要的算力。</p>
<p>这肯定不是面试官想要的答案，要真是这种程度的答案，那这应该是给大一新生的课后作业。</p>
<p>稍加动脑我们就能想出一个另一个看上去也不错的方案，我们将前K个元素单独存储起来，就用一个长度为K的数组，称为ArrayK。这样我们就不再需要排序整个数组，在循环整份数据时，只需将其中的元素与ArrayK中的元素进行比较，如果待比较元素比ArrayK中某一个元素大，就替换该元素，最后只对ArrayK排序一次即可。</p>
<p>那么这个方案的时间复杂度大致是多少呢？</p>
<p>如果最坏情况下每次都需要与ArrayK中的每一个元素进行比较，大致需要<code>O((N-K)*K + K*logK)</code>，忽略掉常数项，即<code>O(N*K)</code>。</p>
<h3 id="是否可以做得更好？"><a href="#是否可以做得更好？" class="headerlink" title="是否可以做得更好？"></a>是否可以做得更好？</h3><p>答案是可以。</p>
<p>上面利用数组的解法还是很low的，但我们已经很接近答案了，ArrayK解决方案的问题在于元素比较次数过多。我们需要一种数据结构，它可以使我们在一堆数据里找最大最小值时比数组更加高效。</p>
<p>这时，<strong>堆</strong>就可以闪亮登场了。</p>
<h2 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>堆是一种特殊的完全二叉树。堆始于<a href="https://zh.wikipedia.org/w/index.php?title=J._W._J._Williams&action=edit&redlink=1" target="_blank" rel="noopener">J. W. J. Williams</a>在1964年发表的<strong>堆排序</strong>（heap sort），当时他提出了二叉堆树作为此算法的数据结构。堆满足以下特性：</p>
<ul>
<li>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（<strong>堆序性</strong>）。</li>
<li>堆总是一棵<a href="https://zh.wikipedia.org/wiki/完全二叉树" target="_blank" rel="noopener">完全树</a>。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</li>
</ul>
<p><img src="/2020/07/29/%E4%BB%8ETop-K%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%E5%85%A5%E6%89%8B%EF%BC%8C%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1%E5%A0%86-Heap-%E7%BB%93%E6%9E%84/image-20200720140013531.png" alt="image-20200720140013531.png"></p>
<p>堆分两种：</p>
<ul>
<li>父节点总是大于等于子节点的堆称为“<code>最大堆/大顶堆</code>”，此时根节点是最大的。</li>
<li>父节点总是小于等于子节点的堆称为“<code>最小堆/小顶堆</code>”，此时根节点是最小的。</li>
</ul>
<p>这个数据结构的重点在于，<strong>根节点永远都是最大/最小值</strong>，所以我们可以很方便的通过获取根节点的方式来获取堆中元素的最大/最小值。父节点永远大于等于（小于等于）子节点，左右子节点的大小顺序没有规定，我们只要保证父比子大（小）即可。</p>
<h3 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h3><p>根据完全二叉树的性质，父节点与子节点的下标位置可以通过数学关系严格定义。其关系如下：</p>
<ul>
<li>假如父节点下标为k，则其左子节点下标为2k，右子节点下标为2K+1。</li>
</ul>
<h4 id="数学证明"><a href="#数学证明" class="headerlink" title="数学证明"></a>数学证明</h4><p><em>注：不感兴趣的同学完全可以跳过这部分。</em></p>
<p>可将堆看作一个公比为2的等比数列，根据求和公式，可得前n层元素个数为：<br>$$<br>S_n=\frac{1\times(1-2^n)}{1-2} = 2^n-1<br>$$</p>
<p>设父节点为第k层第m个节点，则其下标可表示为：<br>$$<br>parent = 2^{k-1} + m - 1<br>$$<br>其左右子节点下标为：<br>$$<br>left = 2^k + 2 \times (m-1)\<br>right = left + 1 = 2^k + 2 \times (m-1) + 1<br>$$<br>可得关系表达式：<br>$$<br>left = 2 \times parent \<br>right = 2 \times parent + 1<br>$$</p>
<h3 id="代码实现（Java）-以最大堆为例"><a href="#代码实现（Java）-以最大堆为例" class="headerlink" title="代码实现（Java）- 以最大堆为例"></a>代码实现（Java）- 以最大堆为例</h3><p>首先要考虑的就是存储结构的选择，堆是一个完全二叉树，子节点与父节点的位置关系可以通过数学公式定义，而且堆的操作中，几乎不存在向数据中间直接塞元素的行为，所以线性存储结构、支持随机读取（Random Access）的数组是最好的选择。</p>
<p>堆的定义代码如下，这里将提供<strong>泛型</strong>方案的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity; <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>; <span class="comment">// 堆中元素个数</span></span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组中索引为i、j的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Object[] array2, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Object temp = array2[i];</span><br><span class="line">        array2[i] = array2[j];</span><br><span class="line">        array2[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取索引位置为i的元素的父节点的索引位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回索引位置为i的元素的左子节点位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * i) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回索引位置为i的元素的右子节点位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * i) + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于堆中元素需要比较大小，所以要求参数类型必须实现Comparable接口，更推荐的作法是不强制要求实现Comparable接口，而是提供一个可以传入比较器的构造函数，在这里为了编码方便我们采取第一种方案。</p>
<h4 id="插入方法（Insert）"><a href="#插入方法（Insert）" class="headerlink" title="插入方法（Insert）"></a>插入方法（Insert）</h4><p>每次插入操作都是将元素插入到数组末尾，然后再与对应的父节点进行比较。整个过程比较简单。</p>
<ul>
<li>最坏情况下比较次数等于树高，故时间复杂度：<code>O(logN)</code></li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入步骤：</span></span><br><span class="line"><span class="comment"> * 1. 在堆的最后新建一个节点并赋值</span></span><br><span class="line"><span class="comment"> * 2. 新节点与父节点比较</span></span><br><span class="line"><span class="comment"> * 3. 如果新节点的数值比父节点大，调换父子节点的位置</span></span><br><span class="line"><span class="comment"> * 4. 重复2、3步，直到最大堆的特性被满足</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(logN)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">         array = Arrays.copyOf(array, capacity * <span class="number">1.5</span>);</span><br><span class="line">         capacity = <span class="number">2</span> * capacity;</span><br><span class="line">         <span class="comment">// throw new IllegalStateException("插入失败，堆中元素数目已达到最大值");</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加至数组末尾</span></span><br><span class="line">    array[size] = item;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 如果新节点的数值比父节点大，调换父子节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> index = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; item.compareTo((T) array[parent(index)]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        swap(array, index, parent(index));</span><br><span class="line">        index = parent(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="取根元素（Poll）"><a href="#取根元素（Poll）" class="headerlink" title="取根元素（Poll）"></a>取根元素（Poll）</h4><p>Poll操作要比Insert复杂一些，直接删除根节点后必须有元素补位，我们让数组中最后一个元素，也就是最小元素代替根节点的位置。这时可能已经不满足最大堆父节点大于等于子节点的性质了，所以需要调整堆结构。</p>
<ul>
<li>与插入操作相同，最坏情况下比较次数等于树高，故时间复杂度：<code>O(logN)</code></li>
</ul>
<p>以下图为例，现在我们要将堆中最大值即大小为90的根节点移除。</p>
<p><img src="/2020/07/29/%E4%BB%8ETop-K%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%E5%85%A5%E6%89%8B%EF%BC%8C%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1%E5%A0%86-Heap-%E7%BB%93%E6%9E%84/image-20200720140123458.png" alt="image-20200720140123458.png"></p>
<p>用最小节点32替换原先的根节点。</p>
<p><img src="/2020/07/29/%E4%BB%8ETop-K%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%E5%85%A5%E6%89%8B%EF%BC%8C%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1%E5%A0%86-Heap-%E7%BB%93%E6%9E%84/image-20200720140622803.png" alt="image-20200720140622803.png"></p>
<p>接下来调整堆结构，将32与子节点中较大者（此处为73）比较，如果比这个较大值要小，则交换位置。直到满足最大堆性质，此处的循环可用递归或while实现。</p>
<p><img src="/2020/07/29/%E4%BB%8ETop-K%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%E5%85%A5%E6%89%8B%EF%BC%8C%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1%E5%A0%86-Heap-%E7%BB%93%E6%9E%84/image-20200720140825613.png" alt="image-20200720140825613.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取出根节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 移除根节点</span></span><br><span class="line"><span class="comment"> * 2. 将最后位置的节点移置根节点处</span></span><br><span class="line"><span class="comment"> * 3. 将子节点和父节点作比较</span></span><br><span class="line"><span class="comment"> * 4. 如果父节点的值比子节点小，交换父子节点位置</span></span><br><span class="line"><span class="comment"> * 5. 重复3、4，直到最大堆的特性被满足</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    T oldRoot = (T) array[<span class="number">0</span>];</span><br><span class="line">    array[<span class="number">0</span>] = array[size - <span class="number">1</span>];</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 调整堆结构</span></span><br><span class="line">    heapifyDown(<span class="keyword">this</span>.array, <span class="number">0</span>, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> oldRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以index为根，向下调整最大堆结构</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapifyDown</span><span class="params">(Object[] array, <span class="keyword">int</span> index, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largeIndex = index;</span><br><span class="line">    <span class="keyword">int</span> nonLeafIndex = len / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 此处可直接以最后一个非叶节点的索引为边界，如JDK PriorityQueue中代码</span></span><br><span class="line">    <span class="keyword">if</span> (largeIndex &lt;= nonLeafIndex) &#123;</span><br><span class="line">        largeIndex = leftChild(index);</span><br><span class="line">        <span class="comment">// 判断左右孩子中较大者</span></span><br><span class="line">        <span class="keyword">int</span> rightIndex = rightChild(index);</span><br><span class="line">        <span class="keyword">if</span> (rightIndex &lt; len) &#123;</span><br><span class="line">            <span class="comment">// 如果右孩子更大，重新赋值largeIndex</span></span><br><span class="line">            <span class="keyword">if</span> (((T) array[largeIndex]).compareTo((T) array[rightIndex]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                largeIndex = rightIndex;</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (((T) array[index]).compareTo((T) array[largeIndex]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将当前节点与子节点中较大者进行交换</span></span><br><span class="line">            swap(array, index, largeIndex);                </span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            heapifyDown(array, largeIndex, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="了解堆之后，重新思考Top-K问题"><a href="#了解堆之后，重新思考Top-K问题" class="headerlink" title="了解堆之后，重新思考Top K问题"></a>了解堆之后，重新思考Top K问题</h2><p><strong>来看看用堆我们能不能得到一个更好的方案？</strong></p>
<p>我们不再使用数组保存前K大元素，而是使用一个最小堆，堆顶是前K个元素中最小的元素。我们遍历整份数据，一旦我们遇到一个比堆中最小元素大的元素，我们要做两件事：</p>
<ol>
<li>从堆中移除最小的那个元素</li>
<li>把这个更大的元素插入到堆中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3, 1, 5, 12, 2, 11], K &#x3D; 3</span><br><span class="line">输出: [5, 12, 11]</span><br></pre></td></tr></table></figure>

<p>以上面的数据为例，总结一下我们的解法分为哪几步：</p>
<ol>
<li>向最小堆中插入K个元素</li>
<li>插入后，堆有三个元素<code>[3, 1, 5]</code>，1因为是最小元素所以在根部</li>
<li>遍历数组中剩下的元素，一旦发现比根部更大的元素，我们就移除堆的根，并插入这个新元素</li>
<li>第四个数是12，比1大，因此它取代了1，现在堆中的元素是<code>[3, 5, 12]</code>，3成为了新的根部</li>
<li>第5个数是2，没3大，pass</li>
<li>最后一个数是11，比3大，所以取代3</li>
</ol>
<p>之前讨论过的，从最小堆里面删除一个元素要<code>O(logK)</code>，我们首先往堆里面插入了<code>K</code>个元素，然后迭代剩余的元素，然后每一步在最坏的情况下，我们都需要进行删除插入操作，我们算法需要的复杂度为<code>O(K∗logK+(N−K)∗logK)</code>。K一般是远远小于N的，很明显，这比<code>O(N∗logN)</code>好多了。</p>
<p>我们只需要记住一个原则：<strong>在一堆数据中追踪前几个符合条件的数据用堆是最高效的</strong>。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>讲完了堆，最后再死磕一下常见到却不常用的<strong>堆排序</strong>。</p>
<p>堆排序算是诸多排序算法中比较难掌握的一个，该算法巧妙利用了堆的性质，如果不了解堆的话，会看得一头雾水。前面已经分析了堆的各种特性与操作，建议你先敲一遍堆代码后再看堆排序，这将容易理解得多。</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>堆排序的过程是：</p>
<ol>
<li>创建一个堆</li>
<li>把堆首（最大值）和堆尾互换</li>
<li>把堆的尺寸缩小1，并调用<code>heapifyDown()</code>,目的是把新的数组顶端数据调整到相应位置</li>
<li>重复步骤2，直到堆的尺寸为1</li>
</ol>
<p>堆排序的平均<a href="https://zh.wikipedia.org/wiki/时间复杂度" target="_blank" rel="noopener">时间复杂度</a>为<code>O(N*logN)</code>，<a href="https://zh.wikipedia.org/wiki/空间复杂度" target="_blank" rel="noopener">空间复杂度</a>为<code>O(1)</code>。</p>
<p><img src="/2020/07/29/%E4%BB%8ETop-K%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%E5%85%A5%E6%89%8B%EF%BC%8C%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1%E5%A0%86-Heap-%E7%BB%93%E6%9E%84/Sorting_heapsort_anim.gif" alt="Sorting heapsort anim.gif"></p>
<h4 id="建堆过程"><a href="#建堆过程" class="headerlink" title="建堆过程"></a>建堆过程</h4><h5 id="两种建堆方案"><a href="#两种建堆方案" class="headerlink" title="两种建堆方案"></a>两种建堆方案</h5><p>有两种情况，第一种情况是待排序元素个数已知；第二种情况是待排元素个数不确定，元素可能是动态增加的。</p>
<p>先讨论比较简单的第二种情况：</p>
<ul>
<li>最容易想到的方案就是利用堆的插入方法，将数组中的元素一个一个的插入堆中。这种情况需要额外建立一个长度为N的堆，空间复杂度为<code>O(N</code>)。每个元素插入的时间复杂度为<code>O(logN)</code>，N个元素的时间复杂度为<code>O(N*logN)</code>。</li>
</ul>
<p>第一种情况更复杂：</p>
<ul>
<li>元素个数已知，也就意味着数组个数是确定的，这时可以进行就地的堆创建，而不需要额外的空间开销。具体做法如下：<ul>
<li>从最后一个非叶子节点一直到根结点进行堆化的调整。如果当前节点小于某个自己的孩子节点（大根堆中），那么当前节点和这个孩子交换。即不断进行heapifyDown操作，这是一种类似下沉的操作。</li>
<li>这种方案的时间复杂度是<code>O(N)</code>。乍一看感觉这和插入方案的调整过程差不多，应该也是<code>O(N*logN)</code>才对。但这种方案在性能上的确要优于插入方案。具体的数学证明过程比较复杂，可以自己去查一下，这里就不写了。</li>
</ul>
</li>
</ul>
<h4 id="排序过程"><a href="#排序过程" class="headerlink" title="排序过程"></a>排序过程</h4><p>假设我们已经读入一系列数据并创建了一个堆，一个最直观的算法就是反复的调用<code>poll()</code>函数，因为该函数总是能够返回堆中最大的值，然后把它从堆中删除，从而对这一系列返回值的输出就得到了该序列的降序排列，但在输出时会用到额外的存储空间。</p>
<p>真正的就地堆排序要更巧妙，过程已经在上面列出来了。就是通过不断交换堆首和堆尾元素，每次交换都能确定一个元素位置，并在每次交换后利用heapifyDown调整堆结构，从而完成排序。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 升序，不稳定排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 时间复杂度O(nlogn)</span></span><br><span class="line"><span class="comment"> * 空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T[] heapSort(T[] array) &#123;</span><br><span class="line">    <span class="comment">// 构建最大堆</span></span><br><span class="line">    buildMaxHeap(array);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 排序，循环n-1次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(array, <span class="number">0</span>, i);</span><br><span class="line">        <span class="comment">// 每次交换后都调整一遍堆结构。heapifyDown方法见上面的堆代码实现</span></span><br><span class="line">        heapifyDown(array, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建最大堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(T[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将传入数组视为完全二叉树，从最后一个非叶子节点开始向前遍历，建立最大堆</span></span><br><span class="line">    <span class="keyword">int</span> index = array.length / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">        heapifyDown(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序与快速排序比较"><a href="#堆排序与快速排序比较" class="headerlink" title="堆排序与快速排序比较"></a>堆排序与快速排序比较</h2><p>为什么实际选择排序算法时很少会选择排序呢？就像Java提供的Arrays.sort方法，其中用的是快速排序。平均时间上，堆排序的时间常数比快排要大一些，因此通常会慢一些，但是堆排序最差时间也是O(nlogn)的，这点比快排好。</p>
<p>那为什么还是选择了快速排序呢？</p>
<h4 id="局部性原理（Locality-of-reference）"><a href="#局部性原理（Locality-of-reference）" class="headerlink" title="局部性原理（Locality of reference）"></a>局部性原理（Locality of reference）</h4><blockquote>
<p><strong>访问局部性</strong>（英语：Locality of reference）指的是在<a href="https://zh.wikipedia.org/wiki/计算机科学" target="_blank" rel="noopener">计算机科学</a>领域中应用程序在访问内存的时候，倾向于访问内存中较为靠近的值。</p>
<p>访问局部性分为两种基本形式，一种是时间局部性，另一种是空间局部性。</p>
<p>时间局部性指的是，程序在运行时，最近刚刚被引用过的一个内存位置容易再次被引用，比如在调取一个<a href="https://zh.wikipedia.org/wiki/函数" target="_blank" rel="noopener">函数</a>的时候，前不久才调取过的<a href="https://zh.wikipedia.org/wiki/本地参数" target="_blank" rel="noopener">本地参数</a>容易再度被调取使用。</p>
<p>空间局部性指的是，最近引用过的内存位置以及其周边的内存位置容易再次被使用。空间局部性比较常见于<a href="https://zh.wikipedia.org/wiki/程式迴圈" target="_blank" rel="noopener">循环</a>中，比如在一个数列中，如果第3个元素在上一个循环中使用，则本次循环中极有可能会使用第4个元素。</p>
<p>局部性是出现在计算机系统中的一种可预测行为。系统的这种强访问局部性，可以被用来在处理器内核的指令流水线中进行性能优化，如缓存，内存预读取以及分支预测。</p>
</blockquote>
<h5 id="分级存储器体系（Hierrachial-memory）"><a href="#分级存储器体系（Hierrachial-memory）" class="headerlink" title="分级存储器体系（Hierrachial memory）"></a>分级存储器体系（Hierrachial memory）</h5><p>更快的存取速度意味着更昂贵的成本，这使设计者在设计时必须作出取舍，一方面要存储足够多的数据，一方面不能拖累CPU的处理速度，还要考虑到成本的限制。因此在计算机体系结构中，为了最大限度的优化系统速度，存储器按照存取速度与存储容量分成了不同的层次。各级存储的速度与容量如下（来自维基百科）：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/CPU_register" target="_blank" rel="noopener">CPU registers</a> (8-256 registers) – immediate access, with the speed of the innermost core of the processor</li>
<li>L1 <a href="https://en.wikipedia.org/wiki/CPU_cache" target="_blank" rel="noopener">CPU caches</a> (32 KiB to 512 <a href="https://en.wikipedia.org/wiki/KiB" target="_blank" rel="noopener">KiB</a>) – fast access, with the speed of the innermost memory bus owned exclusively by each core</li>
<li>L2 CPU caches (128 KiB to 24 <a href="https://en.wikipedia.org/wiki/MiB" target="_blank" rel="noopener">MiB</a>) – slightly slower access, with the speed of the <a href="https://en.wikipedia.org/wiki/Memory_bus" target="_blank" rel="noopener">memory bus</a> shared between twins of cores</li>
<li>L3 CPU caches (2 MiB to 32 <a href="https://en.wikipedia.org/wiki/MiB" target="_blank" rel="noopener">MiB</a>) – even slower access, with the speed of the memory bus shared between even more cores of the same processor</li>
<li>Main <a href="https://en.wikipedia.org/wiki/Physical_memory" target="_blank" rel="noopener">physical memory</a> (<a href="https://en.wikipedia.org/wiki/RAM" target="_blank" rel="noopener">RAM</a>) (256 MiB to 64 <a href="https://en.wikipedia.org/wiki/GiB" target="_blank" rel="noopener">GiB</a>) – slow access, the speed of which is limited by the spatial distances and general hardware interfaces between the processor and the memory modules on the <a href="https://en.wikipedia.org/wiki/Motherboard" target="_blank" rel="noopener">motherboard</a></li>
<li>Disk (<a href="https://en.wikipedia.org/wiki/Virtual_memory" target="_blank" rel="noopener">virtual memory</a>, <a href="https://en.wikipedia.org/wiki/File_system" target="_blank" rel="noopener">file system</a>) (1 GiB to 256 <a href="https://en.wikipedia.org/wiki/TiB" target="_blank" rel="noopener">TiB</a>) – very slow, due to the narrower (in bit width), physically much longer data channel between the main board of the computer and the disk devices, and due to the extraneous software protocol needed on the top of the slow hardware interface</li>
<li>Remote memory (other computers or the cloud) (practically unlimited) – speed varies from very slow to extremely slow</li>
</ul>
<p>现代机器倾向于将较低内存块读入内存层次结构的下一级。如果这替换了已使用的内存，操作系统将尝试预测访问最少（或最新）的数据，并将其向下移动到内存层次结构中。预测算法应该尽量简单，以降低硬件复杂度，虽然它们正变得越来越复杂。</p>
<p>热点数据将被存入CPU中的三级高速缓存(Cache)中，优化程序速度的关键之一就是利用局部性原理，保证数据总是可以在高速缓存中被CPU命中。那么现在我们来分析一下快速排序与堆排序对Cache的友好性是否有差距。</p>
<p>快速排序利用分治法的思想，通过不断产生新的基准值，将原数组不断地划分成两部分，然后进行大小调整。你会发现这里元素在互相比较、交换时，是被限定了范围的，不会出现数组头部与尾部数据进行比较的情况。快排在递归进行部分的排序的时候，一段时间内只会访问局部的数据，因此缓存能够更大概率的命中。</p>
<p>而堆排序不一样，堆排序的比较过程是非常跳跃的，两个交换元素之间的跨度经常很大，很难被集中在一个范围中。堆排序的建堆过程是整个数组各个位置都访问到的，后面则是所有未排序数据各个位置都可能访问到的，所以不利于缓存发挥作用。简单的说就是快排的存取模型的<strong>局部性（locality）</strong>更强，堆排序差一些。</p>
<h4 id="另一种思考"><a href="#另一种思考" class="headerlink" title="另一种思考"></a>另一种思考</h4><p>此部分来自知乎<a href="https://www.zhihu.com/question/23873747/answer/327427621" target="_blank" rel="noopener">为什么在平均情况下快速排序比堆排序要优秀?</a></p>
<ol>
<li>如果我们已知a&lt;b 那么毫无疑问a和b是无需再次做比较的，如果发生的话，我把他称为重复的比较。毫无疑问，对快速排序，重复的比较从来都不会发生，因为a和b第一次比较的时候至少有一个是中柱，而中柱和区间内所有元素比较完毕后是不需要再参加任何比较的，所以a和b不会发生重复比较。</li>
<li>如果我们已知a&lt;b , b&lt;c 那么毫无疑问a和c是无需做比较的，如果发生的话，我把他称为病态的比较。毫无疑问，对快速排序，病态的比较从来都不会发生，因为b就是递归中的那个中柱pivot，b的位置确定之后，a和c所在的区间各自去排序，所以a和c再也不会做比较了。</li>
</ol>
<p>上述观点通过比较操作的次数最小化来进行评估，没有考虑内存&amp;缓存写速率，数据读取缓存有效性等问题。而且同理也可知，归并排序也其实相当高效（然而它内存写操作会多出不少）。</p>
<p>不过<strong>一个值得注意的事实是，快排几十年前就被发现多数情况比堆排快了，而那时候的cpu 除了寄存器基本没cache, 内存读写速率差异不大</strong>，内存读写和cpu的寄存器的差异也不大（所以才不需要什么cache）。所以那时候得出的结论 平均下来快排比堆排快意味着：</p>
<p><strong>平均而言，快排产生的指令数量开销比堆排产生的指令数量开销，是要小的。</strong> </p>
<p>学习算法初步时，考虑性能优劣的话，一般就只考虑指令数量多少吧，别想多了。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Top K</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
</search>
