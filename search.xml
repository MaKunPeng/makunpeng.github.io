<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring-事务传播级别</title>
    <url>/2017/01/05/2017-01-05-Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h2 id="一、TransactionPropagation"><a href="#一、TransactionPropagation" class="headerlink" title="一、TransactionPropagation"></a>一、TransactionPropagation</h2><ul>
<li>PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</li>
<li>PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。</li>
<li>PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。</li>
<li>PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li>PROPAGATION_NESTED – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。<br>前六个策略类似于EJB CMT，第七个（PROPAGATION_NESTED）是Spring所提供的一个特殊变量。<br>它要求事务管理器或者使用JDBC 3.0 Savepoint API提供嵌套事务行为（如Spring的DataSourceTransactionManager）</li>
</ul>
<p>其中对于PROPAGATION_REQUIRES_NEW与PROPAGATION_NESTED的理解上有些类似，关键在于嵌套事务的理解。</p>
<p>来看一下网上大神对Juergen Hoeller表述的翻译：</p>
<blockquote>
<p>PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。</p>
<p>另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务,  它是已经存在事务的一个真正的子事务. 嵌套事务开始执行时,  它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交. </p>
</blockquote>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serviceA.methodA() &#123;</span><br><span class="line">	doSomethingA();</span><br><span class="line">	serviceB.methodB();</span><br><span class="line">	doSomethingB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2017/01/05/2017-01-05-Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%BA%A7%E5%88%AB/image-20200428135125561.png" alt="image"></p>
<h2 id="二、Spring事务之UnexpectedRollbackException异常"><a href="#二、Spring事务之UnexpectedRollbackException异常" class="headerlink" title="二、Spring事务之UnexpectedRollbackException异常"></a>二、Spring事务之UnexpectedRollbackException异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serviceA.methodA()</span><br><span class="line">&#123;  </span><br><span class="line">doSomethingA();  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">            serviceB.methodB&#123;&#125;; <span class="comment">//这里面有异常标记为回滚, doSetRollbackOnly(status);  </span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;  </span><br><span class="line">               <span class="comment">//捕获异常转到commit时，由于已经标记为要回滚， 回滚并抛出新异常     </span></span><br><span class="line">       &#125;         </span><br><span class="line">   doSomethingB();  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>因为在ServiceA和ServiceB中的@Transactional  propagation都采用的默认值：REQUREID。根据我们前面讲过的REQUIRED特性，当ServiceA调用ServiceB的时候，他们是处于同一个transaction中。</p>
<p>当ServiceB中抛出了一个异常以后，ServiceB会把当前的transaction标记为需要rollback。但是ServiceA中捕获了这个异常，并进行了处理，认为当前transaction应该正常commit。但因为methodB有异常事务，已经被标记为回滚，在commit时spring会判断回滚标志，若检测到存在回滚标记， 则回滚事务并抛出UnexpectedRollbackException异常。</p>
]]></content>
      <categories>
        <category>Spring JPA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring JPA</tag>
        <tag>数据库</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim - 快捷键</title>
    <url>/2017/12/24/2017-12-24-Vim-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="Vim-快捷键"><a href="#Vim-快捷键" class="headerlink" title="Vim - 快捷键"></a>Vim - 快捷键</h1><h2 id="启动Vim"><a href="#启动Vim" class="headerlink" title="启动Vim"></a>启动Vim</h2><ul>
<li>vim -c cmd file: 在打开文件前，先执行指定的命令；</li>
<li>vim -r file: 恢复上次异常退出的文件；</li>
<li>vim -R file: 以只读的方式打开文件，但可以强制保存；</li>
<li>vim -M file: 以只读的方式打开文件，不可以强制保存；</li>
<li>vim -y num file: 将编辑窗口的大小设为num行；</li>
<li>vim + file: 从文件的末尾开始；</li>
<li>vim +num file: 从第num行开始；</li>
<li>vim +/string file: 打开file，并将光标停留在第一个找到的string上。</li>
<li>vim –remote file: 用已有的vim进程打开指定的文件。 如果你不想启用多个vim会话，这个很有用。但要注意， 如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了， 你可以用gvim –remote file在已有的gvim中打开文件。</li>
</ul>
<h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><ul>
<li>h或退格: 左移一个字符；</li>
<li>l或空格: 右移一个字符；</li>
<li>j: 下移一行；</li>
<li>k: 上移一行；</li>
<li>gj: 移动到一段内的下一行；</li>
<li>gk: 移动到一段内的上一行；</li>
<li>+或Enter: 把光标移至下一行第一个非空白字符。</li>
<li>-: 把光标移至上一行第一个非空白字符。</li>
<li>w: 前移一个单词，光标停在下一个单词开头；</li>
<li>W: 移动下一个单词开头，但忽略一些标点；</li>
<li>e: 前移一个单词，光标停在下一个单词末尾；</li>
<li>E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点；</li>
<li>b: 后移一个单词，光标停在上一个单词开头；</li>
<li>B: 移动到上一个单词开头，忽略一些标点；</li>
<li>ge: 后移一个单词，光标停在上一个单词末尾；</li>
<li>gE: 同 ge ，不过‘单词’包含单词相邻的标点。</li>
<li>(: 前移1句。</li>
<li>): 后移1句。</li>
<li>{: 前移1段。</li>
<li>}: 后移1段。</li>
<li>fc: 把光标移到同一行的下一个c字符处</li>
<li>Fc: 把光标移到同一行的上一个c字符处</li>
<li>tc: 把光标移到同一行的下一个c字符前</li>
<li>Tc: 把光标移到同一行的上一个c字符后</li>
<li>;: 配合f &amp; t使用，重复一次</li>
<li>,: 配合f &amp; t使用，反向重复一次</li>
</ul>
<p>上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符。</p>
<ul>
<li>0: 移动到行首。</li>
<li>g0: 移到光标所在屏幕行行首。</li>
<li>^: 移动到本行第一个非空白字符。</li>
<li>g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。</li>
<li>$: 移动到行尾。</li>
<li>g$: 移动光标所在屏幕行行尾。</li>
<li>n|: 把光标移到递n列上。</li>
<li>nG: 到文件第n行。</li>
<li>:n<cr> 移动到第n行。</cr></li>
<li>:$<cr> 移动到最后一行。</cr></li>
<li>H: 把光标移到屏幕最顶端一行。</li>
<li>M: 把光标移到屏幕中间一行。</li>
<li>L: 把光标移到屏幕最底端一行。</li>
<li>gg: 到文件头部。</li>
<li>G: 到文件尾部。</li>
</ul>
<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><ul>
<li>m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。</li>
<li>m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。</li>
<li>`{a-z}: 移动到标记位置。</li>
<li>‘{a-z}: 移动到标记行的行首。</li>
<li>`{0-9}：回到上[2-10]次关闭vim时最后离开的位置。</li>
<li>``: 移动到上次编辑的位置。’’也可以，不过``精确到列，而’’精确到行 。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。</li>
<li>`”: 移动到上次离开的地方。</li>
<li>`.: 移动到最后改动的地方。</li>
<li>:marks 显示所有标记。</li>
<li>:delmarks a b – 删除标记a和b。</li>
<li>:delmarks a-c – 删除标记a、b和c。</li>
<li>:delmarks a c-f – 删除标记a、c、d、e、f。</li>
<li>:delmarks! – 删除当前缓冲区的所有标记。</li>
</ul>
<h3 id="翻屏"><a href="#翻屏" class="headerlink" title="翻屏"></a>翻屏</h3><ul>
<li>ctrl+f: 下翻一屏。</li>
<li>ctrl+b: 上翻一屏。</li>
<li>ctrl+d: 下翻半屏。</li>
<li>ctrl+u: 上翻半屏。</li>
<li>ctrl+e: 向下滚动一行。</li>
<li>ctrl+y: 向上滚动一行。</li>
<li>n%: 到文件n%的位置。</li>
<li>zz: 将当前行移动到屏幕中央。</li>
<li>zt: 将当前行移动到屏幕顶端。</li>
<li>zb: 将当前行移动到屏幕底端。</li>
</ul>
<h3 id="选中对象"><a href="#选中对象" class="headerlink" title="选中对象"></a>选中对象</h3><p>按v进入可视模式</p>
<ul>
<li>选中标签内对象，在标签上按vit</li>
<li>选中标签内对象（包括标签），在标签上按vat</li>
</ul>
]]></content>
      <categories>
        <category>Linux使用指南</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程之ThreadLocal</title>
    <url>/2017/12/24/2017-12-25-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal/</url>
    <content><![CDATA[<blockquote>
<p>ThreadLocal - 线程本地变量。顾名思义，ThreadLocal提供了线程内存储变量的能力，这些变量的不同之处在于针对不同的线程，它们各自读取的变量是对应于当前线程的，这些线程持有独立的变量副本，互不影响。通过get和set方法就可以得到当前线程对应的值。</p>
<p>Spring声明式事务的重要实现基础就是ThreadLocal。</p>
</blockquote>
<h2 id="由线程不安全的SimpleDateFormat说起"><a href="#由线程不安全的SimpleDateFormat说起" class="headerlink" title="由线程不安全的SimpleDateFormat说起"></a>由线程不安全的SimpleDateFormat说起</h2><p>SimpleDateFormat是JDK提供的一个常用的日期格式化类，这个类不是线程安全的。如果在日期工具类中，将SimpleDateFormat初始化为一个静态变量以防止多次初始化，那么在并发情况下，调用方法进行格式化的结果可能会出现错误，甚至抛出异常。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>使用局部变量。局部变量是线程私有的，也就不存在线程安全问题。但这样每次调用时都需要初始化SimpleDateFormat，有性能开销。</li>
<li>方法加同步锁synchronized。同步有性能开销，性能会受一定影响。</li>
<li>使用ThreadLocal。阿里巴巴开发手册中推荐使用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadLocal解决方案代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明静态变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; DATE_FORMAT_TL = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">DateFormat df = DATE_FORMAT_TL.get();</span><br></pre></td></tr></table></figure>

<p>使用上述代码，SimpleDateFormat被放入ThreadLocal中，每个线程在调用DATE_FORMAT_TL.get()时，都会从自己的线程本地存储中取变量，如果没有，就会执行initialValue创建一份，并存储在当前线程的本地存储中，下次调用时，当前线程可直接从本地存储中取出已经初始化好的SimpleDateFormat。</p>
<h2 id="与局部变量的区别-聊聊应用场景"><a href="#与局部变量的区别-聊聊应用场景" class="headerlink" title="与局部变量的区别 - 聊聊应用场景"></a>与局部变量的区别 - 聊聊应用场景</h2><p>什么时候使用ThreadLocal呢？</p>
<p>很多人将ThreadLocal的作用单一理解为将一个变量变为线程私有的，从而保证线程安全性，这是片面的，因为想做到这一点的话，使用局部变量就够了。局部变量存在于栈上，天生就是线程私有的，并且用起来还简单。</p>
<p>他们是有很大区别的。</p>
<p>首先，他们的生命周期不同，ThreadLocal的生命周期与线程相同（一般情况下，特殊情况在后面内存泄露一节会讨论），而局部变量的生命周期短的多，方法调用一结束，局部变量就在栈上销毁了。因此ThreadLocal既可以保证变量操作的线程安全性，也保证了同一线程在其生命周期内访问到的ThreadLocal是相同的，这也是SimpleDateFormat中ThreadLocal方案优于其他方案的原因，因为针对当前线程只需创建一次就够了。</p>
<p>其次，局部变量只能应用于方法上，而ThreadLocal可以应用于类属性变量上。</p>
<p><strong>存储单个线程上下文信息</strong></p>
<p>Context类的实现方式之一。</p>
<p><strong>保证类变量的线程安全</strong></p>
<p>一般一个类的属性变量按照java内存模型的设计都属于共享内存（存放在堆中）。一旦涉及多线程编程。对这个变量的修改读取基本都是线程不安全。当然要想安全就要加锁synchonize 或者各种lock. 哪怕是号称线程安全的各种并发类比如ConcurrentHashMap。这种类说是线程安全只是针对ConcurrentHashMap自己的一次get 或者set操作。不意味着多次get set，或者一次get+set的操作。要想一整套get+set都是线程安全还是要加锁。</p>
<p>这时可以使用ThreadLocal，每个线程存储一个变量副本，保证线程安全性。</p>
<p><strong>简化参数传递</strong></p>
<blockquote>
<p>如果我想跟踪一个请求，从接收请求，处理到返回的整个流程，有没有好的办法?</p>
<p>这其实就是线程内共享数据的问题。</p>
</blockquote>
<p>Threadlocal 可以做到传递参数。这是ThreadLocal的一个功能。很多人可能不知道，因为Threadlocal 是线程本地变量，只要线程不销毁，就会一直存在，因此可以使用Threadlocal来跟踪传递参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="number">1</span> 定义一个类读写threadlocal变量</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadAttributes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadAttribues = <span class="keyword">new</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Map&lt;String, Object&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getThreadAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> threadAttribues.get().get(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">setThreadAttribute</span><span class="params">(String name, Object value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> threadAttribues.get().put(name, value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 在一个filter里写入request</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp,</span></span></span><br><span class="line"><span class="function"><span class="params">                        FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">                HttpServletResponse response = (HttpServletResponse) resp;</span><br><span class="line">               </span><br><span class="line">                ThreadAttributes.setThreadAttribute(<span class="string">"request"</span>, req);</span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 读取request</span><br><span class="line">HttpServletRequest request = (HttpServletRequest)ThreadAttributes.getThreadAttribute(<span class="string">"request"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>线程类Thread中有一个类属性，专门存放线程独立的变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal就是用来管理这个threadLocals属性的。也就是说我们对于<code>ThreadLocal</code>的get, set，remove的操作结果都是针对当前线程Thread实例的threadLocals存，取，删除操作。</p>
<p><img src="/2017/12/24/2017-12-25-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal/image-20200407160341549.png" alt="image"></p>
<p><strong>ThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个Entry数组，ThreadLocal确定了一个数组下标，而这个下标就是Entry的对应位置。</strong></p>
<h2 id="潜在的内存泄露风险"><a href="#潜在的内存泄露风险" class="headerlink" title="潜在的内存泄露风险"></a>潜在的内存泄露风险</h2><p><strong>Memory leak:内存泄漏，程序申请内存后，无法释放已申请的内存空间，内存泄漏的堆积终将导致内存溢出。</strong></p>
<h3 id="Java的引用类型"><a href="#Java的引用类型" class="headerlink" title="Java的引用类型"></a>Java的引用类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>回收时间</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>一直存活，除非GC Roots不可达</td>
<td>所有程序的场景，基本对象，自定义对象等</td>
</tr>
<tr>
<td>软引用</td>
<td>内存不足时会被回收</td>
<td>一般用在对内存非常敏感的资源上，用作缓存的场景比较多，例如：网页缓存、图片缓存</td>
</tr>
<tr>
<td>弱引用</td>
<td>只能存活到下一次GC前</td>
<td>生命周期很短的对象，例如ThreadLocal中的Key。</td>
</tr>
<tr>
<td>虚引用</td>
<td>随时会被回收， 创建了可能很快就会被回收</td>
<td>可能被JVM团队内部用来跟踪JVM的垃圾回收活动</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">* its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">* ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">* == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">* entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">* as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么在这里Entry的key要使用弱引用呢？</p>
<p>不妨反过来想想，如果使用强引用，当ThreadLocal对象（假设为ThreadLocal@123456）的引用（是一个强引用，指向ThreadLocal@123456）被回收了，ThreadLocalMap本身（线程对象中）依然还持有ThreadLocal@123456的强引用，如果没有手动删除这个key，则ThreadLocal@123456不会被回收，所以只要当前线程不消亡，ThreadLocalMap引用的那些对象就不会被回收，可以认为这导致Entry内存泄漏。</p>
<p>那使用弱引用的好处呢？</p>
<p>如果使用弱引用，那指向ThreadLocal@123456对象的引用就两个：TL_INT强引用，和ThreadLocalMap中Entry的弱引用。一旦TL_INT被回收，则指向ThreadLocal@123456的就只有弱引用了，在下次gc的时候，这个ThreadLocal@123456就会被回收。</p>
<p>那么问题来了，ThreadLocal@123456对象只是作为ThreadLocalMap的一个key而存在的，现在它被回收了，但是它对应的value并没有被回收，内存泄露依然存在！而且key被删了之后，变成了null，value更是无法被访问到了！针对这一问题，ThreadLocalMap类的设计本身已经有了这一问题的解决方案，那就是在每次get()/set()/remove()ThreadLocalMap中的值的时候，会自动清理key为null的value。如此一来，value也能被回收了。</p>
<p>既然对key使用弱引用，能使key自动回收，那为什么不对value使用弱引用？答案显而易见，假设往ThreadLocalMap里存了一个value，gc过后value便消失了，那就无法使用ThreadLocalMap来达到存储全线程变量的效果了。（但是再次访问该key的时候，依然能取到value，此时取得的value是该value的初始值。即在删除之后，如果再次访问，取到null，会重新调用初始化方法。）</p>
<p>所以我们总结了使用ThreadLocal时会发生内存泄漏的前提条件：</p>
<ol>
<li><p>ThreadLocal引用被设置为null，且后面没有set，get，remove操作。</p>
</li>
<li><p>线程一直运行，不停止。（线程池）</p>
</li>
<li><p>触发了垃圾回收。（Minor GC或Full GC）</p>
</li>
</ol>
<p>我们看到ThreadLocal出现内存泄漏条件还是很苛刻的，所以我们只要破坏其中一个条件就可以避免内存泄漏，但为了更好的避免这种情况的发生我们使用ThreadLocal时遵守以下两个小原则:</p>
<ol>
<li>ThreadLocal申明为private static final。<br>  Private与final 尽可能不让他人修改变更引用，<br>  Static 表示为类属性，只有在程序结束才会被回收。</li>
<li>ThreadLocal使用后务必调用remove方法。<br>   最简单有效的方法是使用后将其移除。</li>
</ol>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle下的分页查询</title>
    <url>/2017/12/30/2017-12-30-Oracle%E4%B8%8B%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="rownum与rowid"><a href="#rownum与rowid" class="headerlink" title="rownum与rowid"></a>rownum与rowid</h2><p>rownum与rowid都是伪列，并不存在于数据表结构定义中。</p>
<h3 id="rownum"><a href="#rownum" class="headerlink" title="rownum"></a>rownum</h3><p>rownum是逻辑上的伪列，是在获取查询结果集后再加上去的 （获取一条记录加一个rownum）。对符合条件的结果添加一个从1开始的序列号。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">rownum</span>,phone_no <span class="keyword">from</span> ur_user_info <span class="keyword">where</span> <span class="keyword">rownum</span> &lt; <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<p>rownum是动态的，先有查询结果，然后再给结果集添加上rownum。</p>
<p><strong>使用误区：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-----错误写法：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">rownum</span>, phone_no</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">rownum</span> rn , phone_no <span class="keyword">from</span> ur_user_info ) a</span><br><span class="line"> <span class="keyword">where</span> a.rownum &gt; <span class="number">5</span></span><br><span class="line">   <span class="keyword">and</span> a.rownum &lt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><strong>错误原因：</strong><br>当产生结果集时，oracle会产生一条rownum为1的记录，显然不符合where条件；那么就会产生第二条记录，同样rownum=1,也不符合记录；  一直下去，导致最后上述sql产生的结果集时空集。 </p>
<p><strong>应用场景</strong></p>
<ul>
<li>分页查询</li>
</ul>
<h3 id="rowid"><a href="#rowid" class="headerlink" title="rowid"></a>rowid</h3><p>ROWID是ORACLE中的一个重要的概念。用于定位数据库中一条记录的一个相对唯一地址值。通常情况下，该值在该行数据插入到数据库表时即被确定且唯一。ROWID它是一个伪列，它并不实际存在于表中。它是ORACLE在读取表中数据行时，根据每一行数据的物理地址信息编码而成的一个伪列。所以根据一行数据的ROWID能找到一行数据的物理地址信息。从而快速地定位到数据行。数据库的大多数操作都是通过ROWID来完成的，而且使用ROWID来进行单记录定位速度是最快的。</p>
<p>要理解索引，必须先搞清楚ROWID。</p>
<p>rowid并不会真正存在于表的data block中,但是他会存在于index当中，用来通过rowid来寻找表中的行数据。</p>
<p><strong>B-Tree索引</strong>的每个索引条目具有两个字段。第一个字段表示索引的键值，对于单列索引来说是一个值；而对于多列索引来说则是多个值组合在一起的。第二个字段表示键值所对应的记录行的ROWID。所以索引能加快查询速度。</p>
<p><strong>特点：</strong></p>
<p>rowid并未存储在表中，所以不支持增删改操作，只能用户查询。 </p>
<p><strong>应用场景</strong></p>
<ul>
<li><p>去重：当多条记录主键相同或者多条记录完全一致时，只需要留下一条记录。（账单表中出现多条一样的数据）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> bal_acctbook_info</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">rowid</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">min</span>(<span class="keyword">rowid</span>)</span><br><span class="line">                       <span class="keyword">from</span> bal_acctbook_info</span><br><span class="line">                      <span class="keyword">where</span> balance_id = <span class="string">'4012562452'</span></span><br><span class="line">                        <span class="keyword">and</span> op_time = <span class="string">'20171212111111'</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="分页查询的几种方式"><a href="#分页查询的几种方式" class="headerlink" title="分页查询的几种方式"></a>分页查询的几种方式</h2><h3 id="利用rownum"><a href="#利用rownum" class="headerlink" title="利用rownum"></a>利用rownum</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">ROWNUM</span> <span class="keyword">AS</span> rowno, t.*</span><br><span class="line">      <span class="keyword">FROM</span> emp t</span><br><span class="line">      <span class="keyword">WHERE</span> hire_date <span class="keyword">BETWEEN</span> <span class="keyword">TO_DATE</span>(<span class="string">'20060501'</span>, <span class="string">'yyyymmdd'</span>)</span><br><span class="line">          <span class="keyword">AND</span> <span class="keyword">TO_DATE</span>(<span class="string">'20060731'</span>, <span class="string">'yyyymmdd'</span>)</span><br><span class="line">        <span class="keyword">AND</span> <span class="keyword">ROWNUM</span> &lt;= (page)*page_size) table_alias</span><br><span class="line"><span class="keyword">WHERE</span> table_alias.rowno &gt;= (page<span class="number">-1</span>)*page_size;</span><br></pre></td></tr></table></figure>

<h3 id="利用分析函数row-number"><a href="#利用分析函数row-number" class="headerlink" title="利用分析函数row_number"></a>利用分析函数row_number</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> </span><br><span class="line">        (<span class="keyword">select</span> row_number()  <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> usenum <span class="keyword">desc</span>) rownumber, t.*</span><br><span class="line">           <span class="keyword">from</span> t_account t)</span><br><span class="line">        <span class="keyword">where</span> rownumber &gt;= <span class="number">10</span> <span class="keyword">and</span> rownumber &lt;= <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>两种方法在性能上差距并不大，并不会因为用了高级函数而提升性能。</p>
<h2 id="分页的坑"><a href="#分页的坑" class="headerlink" title="分页的坑"></a>分页的坑</h2><p>后台分页有一个不可避免的缺点，就是数据变化比较频繁会导致数据遗漏、重叠等，比如取完第1页后，后台删掉了第1页的全部数据，接下去取第2页（实际已经是之前的第3页），会漏掉原本的第2页数据。</p>
<h3 id="分页时，数据出现重复或者排序不稳定"><a href="#分页时，数据出现重复或者排序不稳定" class="headerlink" title="分页时，数据出现重复或者排序不稳定"></a>分页时，数据出现重复或者排序不稳定</h3><p>出现重复的原因：</p>
<p>分页时，如果没有使用order by，oracle不会进行任何排序操作，如果sql没有要求排序，oracle会顺序的从数据块中读取符合条件的数据返回到客户端。所以在没有使用排序sql的时候，分页返回的数据可能是按顺序的，也可能是杂乱无章的，这都取决与数据的存储位置。</p>
<p>在分页查询过程中，如果数据的物理位置发生了改变，就可能会引起分页数据重复的现象。 <strong>所以，要正确使用分页查询，sql语句中必须有排序条件。</strong></p>
<p>但是，在有排序条件的时候，仍然会出现数据重复的现象，这是为什么呢？<br>通过了解oracle的排序机理就会明白，出现这种情况的原因是因为排序列值的不唯一性。 Oracle这里使用的排序算法不具有稳定性，也就是说，对于键值相等的数据，这种算法完成排序后，不保证这些键值相等的数据保持排序前的顺序.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> row_.*, <span class="keyword">rownum</span> rownum_</span><br><span class="line">          <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> createtime) row_</span><br><span class="line">         <span class="keyword">where</span> <span class="keyword">rownum</span> &lt;= <span class="number">10</span>)</span><br><span class="line"> <span class="keyword">where</span> rownum_ &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>内层结果集如果加入排序字段，比如：CREATETIME（创建日期），会发现筛选出来的结果集并不稳定，这个跟Oracle的排序机理有关系。</p>
</blockquote>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>需要给sql加入排序唯一的排序字段。我们知道，排序时当有多个字段时，从左到右的排序方式进行排序，排在前面的优先级高，写法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> row_.*, <span class="keyword">rownum</span> rownum_</span><br><span class="line">          <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> createtime <span class="keyword">desc</span>, <span class="keyword">id</span> <span class="keyword">asc</span>) row_</span><br><span class="line">         <span class="keyword">where</span> <span class="keyword">rownum</span> &lt;= <span class="number">10</span>)</span><br><span class="line"> <span class="keyword">where</span> rownum_ &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>order by语句应当遵循条件唯一性原则，否则oracle不保证每次查询的结果集都相同。</li>
<li>分页时，sql语句中需要有排序条件。 并且，排序条件如果没有唯一性，那么必须在后边跟上一个唯一性的条件，比如主键。</li>
</ul>
]]></content>
      <categories>
        <category>Oracle基础</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Nginx的安装</title>
    <url>/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>环境：阿里云ECS Centos7</p>
</blockquote>
<h2 id="1-下载源码包"><a href="#1-下载源码包" class="headerlink" title="1. 下载源码包"></a>1. 下载源码包</h2><p>路径一般选择/usr下</p>
<blockquote>
<p>wget -c <a href="https://nginx.org/download/nginx-1.16.1.tar.gz" target="_blank" rel="noopener">https://nginx.org/download/nginx-1.16.1.tar.gz</a></p>
</blockquote>
<h2 id="2-安装所需依赖"><a href="#2-安装所需依赖" class="headerlink" title="2. 安装所需依赖"></a>2. 安装所需依赖</h2><blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y gcc-c++ #编译器</span><br><span class="line">yum install -y pcre pcre-devel #正则表达式</span><br><span class="line">yum install -y zlib zlib-devel #压缩算法</span><br><span class="line">yum install -y openssl openssl-devel #如果使用HTTPS，需要安装OpenSSL</span><br></pre></td></tr></table></figure>
</blockquote>
<p>devel 包主要是供开发用，至少包括以下2个东西:</p>
<ol>
<li>头文件</li>
<li>链接库<br>有的还含有开发文档或演示代码。</li>
</ol>
<p>以 glib 和 glib-devel 为例:</p>
<p>如果你安装基于 glib 开发的程序，只需要安装 glib 包就行了。</p>
<p>但是如果你要编译使用了 glib 的源代码，则需要安装 glib-devel。</p>
<h2 id="3-编译安装"><a href="#3-编译安装" class="headerlink" title="3. 编译安装"></a>3. 编译安装</h2><p>命令讲解</p>
<p>来自于GNU的AUTOCONF和AUTOMAKE工具。</p>
<ol>
<li><p>./configure 是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。</p>
<blockquote>
<p>这一步一般用来生成  Makefile，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，比如代码:./configure  –prefix=/usr 意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin （而不是默认的  /usr/local/bin),资源文件就会安装在  /usr/share（而不是默认的/usr/local/share）。同时一些软件的配置文件你可以通过指定 –sys-config=  参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许  ./configure –help 察看详细的说明帮助。</p>
</blockquote>
</li>
</ol>
<p>　2. make 是用来编译的，它从Makefile中读取指令，然后编译。</p>
<p>　3. make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。</p>
<p>解压</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure>
</blockquote>
<p>执行configure脚本，生成Makefile文件。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure>
</blockquote>
<p>编译</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="4-运行"><a href="#4-运行" class="headerlink" title="4. 运行"></a>4. 运行</h2><p>进入默认安装目录/usr/local，会发现已经创建了一个名为nginx的文件夹。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx #运行</span><br><span class="line">./nginx -s quit 或 ./nginx -s stop #关闭nginx</span><br><span class="line">./nginx -s reload #重启</span><br></pre></td></tr></table></figure>
</blockquote>
<p>查看nginx进程</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux | grep nginx</span><br></pre></td></tr></table></figure>
</blockquote>
<p>设置开机启动</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/rc.local</span><br><span class="line"><span class="meta">#</span><span class="bash">在文件底部增加启动代码即可</span></span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="5-问题解决"><a href="#5-问题解决" class="headerlink" title="5. 问题解决"></a>5. 问题解决</h2><h3 id="问题场景1"><a href="#问题场景1" class="headerlink" title="问题场景1"></a>问题场景1</h3><p>服务器重启后，重启nginx时报错nginx: [error] open()  “/usr/local/nginx/logs/nginx.pid” failed (2: No such file or  directory)，进入到logs目录发现确实没有nginx.pid文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;</span><br><span class="line">.&#x2F;nginx -s reload</span><br><span class="line">ngx_http_fastdfs_set pid&#x3D;1412</span><br><span class="line">ngx_http_fastdfs_set pid&#x3D;1412</span><br><span class="line">ngx_http_fastdfs_set pid&#x3D;1412</span><br><span class="line">ngx_http_fastdfs_set pid&#x3D;1412</span><br><span class="line">nginx: [error] open() &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&quot; failed (2: No such file or directory)</span><br></pre></td></tr></table></figure>

<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>使用指定nginx.conf文件的方式重启nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p>还有一种可能就是nginx.conf的nginx.pid被注释了,将下图中pid前的#去掉,保存退出再次启动nginx。</p>
<p>此时去logs目录下查看发现nginx.pid文件已经生成了。</p>
<h3 id="问题场景2"><a href="#问题场景2" class="headerlink" title="问题场景2"></a>问题场景2</h3><p>ngnix配置完成后外网无法访问</p>
<h4 id="第一种可能"><a href="#第一种可能" class="headerlink" title="第一种可能"></a>第一种可能</h4><p>阿里云服务器安全组配置中未配置80端口的访问规则。配置完即可。</p>
<h4 id="第二种可能"><a href="#第二种可能" class="headerlink" title="第二种可能"></a>第二种可能</h4><p>如果配置完阿里云服务器安全组策略后依然不可以，则考虑是Linux防火墙的问题。</p>
<p>所以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ]# &#x2F;sbin&#x2F;iptables -I INPUT -p tcp --dport 80 -j ACCEPT  </span><br><span class="line">[root@localhost ]# &#x2F;etc&#x2F;init.d&#x2F;iptables save  </span><br><span class="line">[root@localhost ]# &#x2F;etc&#x2F;init.d&#x2F;iptables restart</span><br></pre></td></tr></table></figure>

<p> 查找防火墙的文件命令：</p>
<p>vim /etc/sysconfig/iptables</p>
<p>打开文件之后会有：-A INPUT -p -tcp -m –dport 80 -j ACCEPT 此为打开了80端口</p>
<p>修改之后重启：service iptables restart</p>
<blockquote>
<p>Centos7中进行上述操作会报错，错误及解决方案如下</p>
</blockquote>
<p>报错：</p>
<p>Redirecting to /bin/systemctl restart iptables.service<br>Failed to restart iptables.service: Unit not found.</p>
<p>原因是因为CentOS7 里面是用 firewalld (相关介绍介绍请点击)来管理防火墙的。</p>
<ol>
<li><p>执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示FirewallD is not running，如下图所示。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/7dd98d1001e939013391d96372ec54e737d196df.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
<li><p>通过systemctl status firewalld查看firewalld状态，发现当前是dead状态，即防火墙未开启。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/55e736d12f2eb93882fe2eafdc628535e4dd6fdf.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
<li><p>通过systemctl start firewalld开启防火墙，没有任何提示即开启成功。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/e61190ef76c6a7efec9afc7bf4faaf51f3de662a.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
<li><p>再次通过systemctl status firewalld查看firewalld状态，显示running即已开启了。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/503d269759ee3d6d9f44d3964a166d224e4adee9.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
<li><p>如果要关闭防火墙设置，可能通过systemctl stop firewalld这条指令来关闭该功能。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/2e2eb9389b504fc2cecce458ecdde71191ef6ddf.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
<li><p>再次执行执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示success，表示设置成功，这样就可以继续后面的设置了。</p>
<p><img src="/2018/01/07/2018-01-07-Linux%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85/42166d224f4a20a4969c689a99529822730ed0e9.jpg" alt="centos出现“FirewallD is not running”怎么办"></p>
</li>
</ol>
<p>添加80端口为允许：</p>
<p>firewall-cmd –zone=public –add-port=80/tcp –permanent （–permanent 没有此参数重启后失效）</p>
]]></content>
      <categories>
        <category>Ngnix</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security - 认证授权的基本概念</title>
    <url>/2018/02/01/Spring%20Security%20-%20%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="一、认证"><a href="#一、认证" class="headerlink" title="一、认证"></a>一、认证</h2><p><strong>认证就是判断一个用户身份是否合法的过程。</strong></p>
<p>认证是为了保护系统的隐私数据与资源，用户身份合法是访问资源的前提。例如，登陆QQ时，需要输入用户名和密码，这就是一个认证的过程。只有用户名、密码校验通过后，用户才能继续操作。</p>
<p>常见的认证方式有：用户名密码登录、二维码登录、短信登录、指纹认证等等。</p>
<h2 id="二、会话"><a href="#二、会话" class="headerlink" title="二、会话"></a>二、会话</h2><blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/计算机科学" target="_blank" rel="noopener">计算机科学</a>领域来说，尤其是在<a href="https://zh.wikipedia.org/wiki/计算机网络" target="_blank" rel="noopener">网络</a>领域，<strong>会话</strong>（<strong>session</strong>，Microsoft Windows 中文版译作<strong>工作阶段</strong>）是一种持久网络协议，在用户（或用户代理）端和服务器端之间创建关联，从而起到交换数据包的作用机制，session在<a href="https://zh.wikipedia.org/wiki/网络协议" target="_blank" rel="noopener">网络协议</a>（例如<a href="https://zh.wikipedia.org/wiki/Telnet" target="_blank" rel="noopener">telnet</a>或<a href="https://zh.wikipedia.org/wiki/FTP" target="_blank" rel="noopener">FTP</a>）中是非常重要的部分。</p>
<p>在不包含<a href="https://zh.wikipedia.org/wiki/会话层" target="_blank" rel="noopener">会话层</a>（例如<a href="https://zh.wikipedia.org/wiki/UDP" target="_blank" rel="noopener">UDP</a>）或者是无法长时间驻留<a href="https://zh.wikipedia.org/wiki/会话层" target="_blank" rel="noopener">会话层</a>（例如<a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP</a>）的传输协议中，会话的维持需要依靠在传输数据中的高级别程序。例如，在浏览器和远程主机之间的HTTP传输中，HTTP cookie就会被用来包含一些相关的信息，例如session ID，参数和权限信息等。</p>
<p>—- 来自维基百科</p>
</blockquote>
<p>在认证授权系统中，为了避免用户每一次操作都需要进行繁琐的认证，大都选择将用户的认证信息保存在会话中，使用会话来记录并保持当前用户的登录状态。这样用户只需在第一次登陆时进行认证，后续操作会自动从会话中取出用户认证信息，极大方便了用户的操作。</p>
<p>认证系统中，会话常见的实现方式有基于session的方式，基于token的方式等等。</p>
<h3 id="2-1-基于Session的认证"><a href="#2-1-基于Session的认证" class="headerlink" title="2.1 基于Session的认证"></a>2.1 基于Session的认证</h3><p>Session是一种服务器端的会话机制，被广泛应用于Web应用中。由于HTTP是一种无状态协议，所以当需要记录用户状态时，就需要用某种机制来识具体的用户，这个机制可以用Session实现。典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。这个数据可以保存在集群、数据库、文件中。</p>
<p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>
<p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
<h3 id="2-2-基于Token的认证"><a href="#2-2-基于Token的认证" class="headerlink" title="2.2 基于Token的认证"></a>2.2 基于Token的认证</h3><p>Token是用户登录成功后，服务端生成的一段包含了特殊信息的数字令牌。与Session相同，Token也会被返回到客户端，但客户端保存Token的方式更灵活，可以保存到Cookie中也可以存到Local Storage中。这样用户后续的访问会携带这个Token，服务器通过验证这个Token来判断用户的登录状态。</p>
<h3 id="2-3-两种方式的区别"><a href="#2-3-两种方式的区别" class="headerlink" title="2.3 两种方式的区别"></a>2.3 两种方式的区别</h3><p>除了上面提到的客户端保存认证信息的方式不同外，两种方式在服务器端的实现也是有很大差别的。</p>
<ul>
<li>基于Session的认证方式由Servlet规范制定，服务端需要存储Session信息，这会占用一定资源，而且在分布式场景下会带来一些问题，这个我们后续会提到。</li>
<li>基于Token的认证方式不需要服务端存储Token，并且不限制客户端的存储方式。万物互联的今天，越来越多类型的客户端需要接入系统，系统多是采用前后分离的方式实现，故使用Token更为合适。</li>
</ul>
<h2 id="三、授权"><a href="#三、授权" class="headerlink" title="三、授权"></a>三、授权</h2><h3 id="3-1-什么是授权"><a href="#3-1-什么是授权" class="headerlink" title="3.1 什么是授权"></a>3.1 什么是授权</h3><p>一个应用是由多个功能模块和无数的资源组成的，而这些功能和资源往往不会全部对用户开放，多是有条件、有选择的对用户开放。比如，百度网盘的很多功能是需要开通会员后才能使用的，这些功能就是由用户权限控制的。</p>
<p>授权位于认证之后，是为了更细粒度的控制用户对资源的访问。系统会根据用户的权限来控制用户对不同资源的访问。</p>
<h3 id="3-2-授权的数据模型"><a href="#3-2-授权的数据模型" class="headerlink" title="3.2 授权的数据模型"></a>3.2 授权的数据模型</h3><ul>
<li>Who，主体（Subject），一般指用户</li>
<li>What，资源（Resource），分为功能资源（系统菜单）和数据资源（商品信息）</li>
<li>How，权限（Permission），用户操作权限</li>
</ul>
<p>相关的数据模型（数据库表）如下：</p>
<p>主体（用户ID，帐号，密码，……）</p>
<p>资源（资源ID，资源名称，访问路径，……）</p>
<p>权限（权限ID，权限标识，权限名称，资源ID，……）</p>
<p>角色（角色ID，角色名称，……）</p>
<p>角色和权限关系表（角色ID，权限ID，……）</p>
<p>主体和角色关系表（用户ID，角色ID，……)</p>
<p><img src="/2018/02/01/Spring%20Security%20-%20%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E6%9D%83%E9%99%90%E8%A1%A8.png" alt></p>
<p>通常生产实践中会将资源和权限表合并为一张表，这样一共五张表。</p>
<h2 id="四、RBAC"><a href="#四、RBAC" class="headerlink" title="四、RBAC"></a>四、RBAC</h2><h3 id="4-1-基于角色的访问控制（Role-Based-Access-Control）"><a href="#4-1-基于角色的访问控制（Role-Based-Access-Control）" class="headerlink" title="4.1 基于角色的访问控制（Role-Based Access Control）"></a>4.1 基于角色的访问控制（Role-Based Access Control）</h3><p>判断逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.hasRole(<span class="string">"经理"</span>)) &#123;</span><br><span class="line">	查询人员();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上图查询人员功能所需的角色发生了变化，则需要修改判断逻辑代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.hasRole(<span class="string">"经理"</span>) || user.hasRole(<span class="string">"HR"</span>)) &#123;</span><br><span class="line">    查询人员();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦变化，需要修改源代码，扩展性较差。</p>
<h3 id="4-2-基于资源的访问控制（Resource-Based-Access-Control）"><a href="#4-2-基于资源的访问控制（Resource-Based-Access-Control）" class="headerlink" title="4.2 基于资源的访问控制（Resource-Based Access Control）"></a>4.2 基于资源的访问控制（Resource-Based Access Control）</h3><p>判断逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.hasPermission(<span class="string">"查询人员权限"</span>)) &#123;</span><br><span class="line">    查询人员();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：系统设计时定义好功能资源的权限标识，即使角色发生变化，也不会表现在代码上。可扩展性强。</p>
]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
        <tag>访问控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Java阻塞队列 - DelayQueue（延迟队列）</title>
    <url>/2018/05/13/DelayQueue%EF%BC%88%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>一种由延迟元素组成的无边界阻塞队列，其中一个元素只有在其延迟过期时才能被接受。队列的头是最快过期的延迟元素。如果没有延迟过期，则没有head，poll将返回null。当元素的getDelay（TimeUnit.NANOSECONDS）方法返回的值小于或等于零时，将发生过期。即使使用take或poll不能删除未过期的元素，也可以将它们视为正常元素。例如，size方法返回过期和未过期元素的计数。此队列不允许空元素（null）。</p>
<p>这个类及其迭代器实现了集合和迭代器接口的所有可选方法。方法Iterator()中提供的迭代器不能保证以任何特定顺序遍历DelayQueue的元素。</p>
<p>这个类是Java集合框架的成员。</p>
<p>—- Doug Lea</p>
</blockquote>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在我们的业务中通常会有一些需求是这样的： </p>
<ol>
<li>淘宝订单业务:<code>下单之后如果三十分钟之内没有付款就自动取消订单</code>。</li>
<li>饿了吗订餐通知:<code>下单成功后60s之后给用户发送短信通知</code>。</li>
<li>缓存系统的设计，缓存中的对象，超过了空闲时间，需要从缓存中移出。</li>
<li>……</li>
</ol>
<p>这类业务我们可以总结出一个特点:需要延迟工作。 </p>
<p>DelayQueue可以满足这类需求。</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>首先，DelayQueue规则定了队列中的元素必须实现Delayed接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Thread leader = <span class="keyword">null</span>; <span class="comment">// 等待队头元素的线程</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由源码可以看出DelayQueue内部使用了优先级队列PriorityQueue来保存元素。当调用DelayQueue的offer方法时，把Delayed对象加入到优先队列q中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        q.offer(e);</span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123; <span class="comment">// 如果新加入的元素是最快过期的元素</span></span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal(); <span class="comment">//唤醒阻塞的消费者线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DelayQueue的take方法，把优先队列q的first拿出来（peek），如果没有达到延时阀值，则进行await处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 调用后一直阻塞直到获得锁,但是接受中断信号</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// for(;;)比while(true)生成的字节码指令更少，不占用寄存器，而且没有判断跳转</span></span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await(); <span class="comment">// 如果没有元素，直接阻塞</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS); <span class="comment">// 判断是否过期</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) <span class="comment">// 如果过期了，直接弹出队头</span></span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await(); <span class="comment">// 如果没过期，且已经有leader在等待队头元素，则继续阻塞等待,同时释放锁</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        available.awaitNanos(delay); <span class="comment">// 如果leader就是当前线程，则阻塞指定的延迟时间</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DelayQueue的线程安全性是由ReentrantLock保证的。线程进入方法后会先获取锁，如果获取不到，会阻塞直至获取，如果获取到了，就会继续操作，此时如果获取的元素未过期，则本线程阻塞，一旦阻塞就会释放当前线程持有的锁。</p>
<p>当一个线程成为leader时，它只等待下一个延迟过去，而其他线程则无限期地等待。leader线程必须在从 take() 或 poll(…) 返回之前向其他线程发出信号，除非其他线程在此期间成为引导线程。</p>
<h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><p>下面以一个简单的生产者-消费者的例子来展示DelayQueue的延时处理。我们将向一个延时队列中扔进一堆延迟时间不等的任务，然后单独开启一个线程从队列中消费数据。</p>
<p>任务对象必须实现Delayed接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> delayTime; <span class="comment">// 多久之后执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTime; <span class="comment">// 过期时间点</span></span><br><span class="line">    <span class="keyword">private</span> String taskName; <span class="comment">// 任务名称</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String taskName, <span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskName = taskName;</span><br><span class="line">        <span class="keyword">this</span>.delayTime = delayTime;</span><br><span class="line">        <span class="keyword">this</span>.expireTime = System.nanoTime() + TimeUnit.NANOSECONDS.convert(delayTime, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写比较方法，让队列中的元素按照过期时间来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> d = (<span class="keyword">this</span>.getDelay(TimeUnit.NANOSECONDS) - o.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">        <span class="keyword">return</span> d &gt; <span class="number">0</span> ? <span class="number">1</span> : d &lt; <span class="number">0</span> ? -<span class="number">1</span> :<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// return (int) d; 这里绝对不能使用强制转换，极易出现上限溢出后发生数据截断。导致最后排序结果不符合预期。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(<span class="keyword">this</span>.expireTime - System.nanoTime(), TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Task:"</span> + taskName + <span class="string">" [delayTime="</span> + delayTime + <span class="string">", expireTime="</span> + expireTime + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> DelayQueue&lt;Task&gt; taskQueue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">    Thread producer = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                taskQueue.put(<span class="keyword">new</span> Task(i + <span class="string">""</span>, i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    producer.start();</span><br><span class="line">    </span><br><span class="line">    Thread consumer = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="comment">// 消费队列中的过期元素，执行doAction</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Task task;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task = taskQueue.take();</span><br><span class="line">                    task.doAction();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    consumer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下，各个任务依次打印：</p>
<p><img src="/2018/05/13/DelayQueue%EF%BC%88%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%EF%BC%89/image-20200513171457561.png" alt="image-20200513171457561"></p>
<p>这里还有一个实现缓存的例子，链接如下：<br> <a href="https://link.jianshu.com?t=http://www.cnblogs.com/jobs/archive/2007/04/27/730255.html" target="_blank" rel="noopener">http://www.cnblogs.com/jobs/archive/2007/04/27/730255.html</a></p>
<h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><p>在实现Delayed接口时，重写compareTo()方法是很重要的，只有compareTo()方法没有问题，才能保证队列中元素是按过期时间排序的。如果不重写，则需要传入比较器。</p>
<p>DelayQueue中的元素可以通过remove方法移除，此时请保证equals与hashCode方法的正确性。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>阻塞队列</tag>
      </tags>
  </entry>
</search>
